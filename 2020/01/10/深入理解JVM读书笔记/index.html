<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="googlea13c34376ca8a2f0.html" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="读书笔记," />





  <link rel="alternate" href="/atom.xml" title="WCXDHR Blog" type="application/atom+xml" />






<meta name="description" content="Java内存区域与内存溢出异常 运行时数据区域程序计数器一块较小的内存空间，可以看作当前线程所执行字节码的行号执行器。 Java虚拟机规范中唯一未规定任何OutOfMemoryError的情况的区域。">
<meta name="keywords" content="读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解JVM读书笔记">
<meta property="og:url" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/index.html">
<meta property="og:site_name" content="WCXDHR Blog">
<meta property="og:description" content="Java内存区域与内存溢出异常 运行时数据区域程序计数器一块较小的内存空间，可以看作当前线程所执行字节码的行号执行器。 Java虚拟机规范中唯一未规定任何OutOfMemoryError的情况的区域。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1569306828310.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1569311242265.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1569311296712.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1570519830535.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1570522647752.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1570523031280.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1570523642697.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1570605698632.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1570606028792.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1570606950976.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1570607165870.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1570607480233.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1570609405994.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1571020555905.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1571020703366.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1571034765227.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1571038131082.png">
<meta property="og:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1571902123343.png">
<meta property="og:updated_time" content="2020-01-10T03:27:58.224Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解JVM读书笔记">
<meta name="twitter:description" content="Java内存区域与内存溢出异常 运行时数据区域程序计数器一块较小的内存空间，可以看作当前线程所执行字节码的行号执行器。 Java虚拟机规范中唯一未规定任何OutOfMemoryError的情况的区域。">
<meta name="twitter:image" content="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/1569306828310.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/"/>





  <title>深入理解JVM读书笔记 | WCXDHR Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?88497255be7fde2d6459ede657c75534";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WCXDHR Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WCXDHR">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WCXDHR Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解JVM读书笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-10T11:13:17+08:00">
                2020-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深入理解JVM笔记/" itemprop="url" rel="index">
                    <span itemprop="name">深入理解JVM笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><img src="/2020/01/10/深入理解JVM读书笔记/1569306828310.png">
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>一块较小的内存空间，可以看作当前线程所执行字节码的行号执行器。</p>
<p>Java虚拟机规范中唯一未规定任何<strong>OutOfMemoryError</strong>的情况的区域。<a id="more"></a></p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>线程私有，与线程的生命周期相同。描述Java方法执行的内存模型：每个方法在运行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应着从入栈到出栈的过程。</p>
<p><strong>注</strong>：通常把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，这里所指的“栈”就是虚拟机栈，或虚拟机栈中局部变量表的地方。</p>
<p><strong>两种异常</strong>：</p>
<ul>
<li><p>StackOverflowError </p>
<p>线程请求的栈深度大于虚拟机所允许的深度。</p>
</li>
<li><p>OutOfMemoryError</p>
<p>（若虚拟可以动态扩展）扩展时无法申请到足够的内存</p>
</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈类似，不过为Native方法服务，部分虚拟机（例如Sun HotSpot）直接将两者合一。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>线程共享，存放对象实例，几乎所有的对象实例都要在堆上分配内存。</p>
<p>Java堆是垃圾收集器管理的主要区域。</p>
<p>物理上可以不连续，逻辑上连续即可。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。过去，方法区被称为“永久代”（涉及分代收集算法，按照对象的生命周期进行划分，使用不同的垃圾回收算法）</p>
<p>Java虚拟机规范对方法区限制十分宽松，除和Java堆一样不需要连续内存和可以选择固定大小或者可扩展外，可以选择不实现垃圾收集。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行常量池（Runtime Constant Pool）是<strong>方法区</strong>的一部分。用于存放Class文件中的常量池（Constant Pool Table）（存放编译期生成的各种字面量和符号引用）。</p>
<p>运行时常量池具有动态性，运行时可以将新的常量放入池中。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>本机直接分配的内存，受到本机总内存的限制。</p>
<h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ul>
<li>虚拟机遇到一条new指令，首先检查指令参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。若没有，则必须先执行类加载过程。</li>
<li>类加载通过后，为新生对象分配内存，分配的内存大小在类加载后便完全确定。内存分配时，一般有指针碰撞（内存规整）和空闲列表（内存相互交错）。Java堆是否规整由采用的垃圾收集器是否带有压缩整理功能决定。分配内存时还有线程安全问题，解决方法有两种：一是对分配动作继续同步处理，二是为每个线程在堆上预先分配一小块内存——本地线程分配缓冲（TLAB），只有TLAB用完分配新的TLAB时需要同步锁定。</li>
<li>内存分配完后，虚拟机将分配到的内存空间都初始化为零值。</li>
<li>接下来，对对象进行必要的设置，例如对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存储在<strong>对象头</strong>中。</li>
<li>上面工作完成后，虚拟机视角的新对象已经产生，但Java程序视角对象才刚刚开始创建，接下来执行<init> 方法。</init></li>
</ul>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充。</p>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>对象头分为两部分：</p>
<ul>
<li>用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等等，官方称为“Mark Word”。</li>
<li>类型指针，即对象指向它的类元数据的指针（并不是所有的虚拟机实现都必须保留类型指针。</li>
</ul>
<p>另外，若对象是数组，则对象头中还必须有一块用于记录数组长度。</p>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>对象真正存储的有效信息，存储顺序受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</p>
<h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>不是必要存在，要求对象长度必须是8字节的整数倍。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。</p>
<p>主流对象访问方式有两种：</p>
<ul>
<li><p>句柄访问</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1569311242265.png">
<p>​</p>
</li>
<li><p>直接指针访问</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1569311296712.png">
<p>​</p>
</li>
</ul>
<p>句柄的优点：reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p>
<p>直接指针的优点：速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p>
<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="判断对象是否死去"><a href="#判断对象是否死去" class="headerlink" title="判断对象是否死去"></a>判断对象是否死去</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象添加一个引用计数器，计数为0的对象则不再使用。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>主流商用语言（Java、c#等）的主流实现中，通过可达性分析来判定对象是否存活。</p>
<p>基本思想：从GC Roots的对象开始往下搜索，走过的路径称为引用链，当一个对象到GC Roots没有任何引用链，则从GC Roots到这个对象不可达，对象不可用。</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1570519830535.png">
<p><strong>注</strong>：Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>JDK1.2之后，Java对引用的概念进行了补充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用：普遍存在，例如new方法。存在时垃圾收集器不会回收。</li>
<li>软引用：用来描述一些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回 收还没有足够的内存，才会抛出内存溢出异常。</li>
<li>弱引用：描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾收集之前。</li>
<li>虚引用：也称幽灵引用或者幻影引用。它是最弱的一种引用关系。一个对象是否有虚引 用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一 个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>可达性分析后不可达的对象，并非“非死不可”。</p>
<p>真正宣告一个对象死亡，至少经历两次标记过程：</p>
<ul>
<li>可达性分析后进行第一次标记并筛选对象是否需要执行finalize（）方法。当对象没有覆盖finalize（）方法，或 者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</li>
<li>执行finalize（）方法时若重新建立引用连接，则第二次标记时移除出回收集合，否则对象将被回收。</li>
</ul>
<p><strong>注：</strong>任何对象的finalize（）方法只能被系统调用一次。（建议不要使用该方法）</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区（永久代）的垃圾回收包括两部分：废弃常量和无用的类。</p>
<p>判断一个常量是否废弃比较简单，而判定一个类是否无用则需要满足以下条件：</p>
<ul>
<li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</p>
</li>
<li><p>加载该类的ClassLoader已经被回收。 </p>
</li>
<li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该 </p>
<p>类的方法。 </p>
</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法（Mark-Sweep"><a href="#标记-清除算法（Mark-Sweep" class="headerlink" title="标记-清除算法（Mark-Sweep)"></a>标记-清除算法（Mark-Sweep)</h3><p>分为标记和清楚两部分。</p>
<p>法如其名。（标记方法如前所述）</p>
<p>主要不足：</p>
<ul>
<li><p>效率问题：标记和清楚过程的效率不高</p>
</li>
<li><p>空间问题：清除后产生大量不连续的内存碎片，可能导致以后下次分配大对象时无连续可用内存而再次触发垃圾收集。</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1570522647752.png">
<p>​</p>
</li>
</ul>
<h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p>为了解决效率问题。</p>
<p>将内存按容量分为大小相等的两块，每次只使用其中一块，当这一块内存用完，则将还存活的对象复制到另一半中，将这一块一次清理掉。不用考虑碎片问题，实现简单，运行高效。</p>
<p>算法代价太高，将内存直接减半。</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1570523031280.png">
<p>现在的商用虚拟机都采用这种算法来回收<strong>新生代</strong>，由于新生代中对象98%是“朝生夕死”的，不需要按照1：1来分配空间。而是将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。回收时，Eden和Survivor中的存活对象复制到另一块Survivor中，再一次清理掉刚才的空间。HotSpot中默认Eden：Survivor为8：1。（当Survivor不够时，需要依赖老年代进行分配担保）</p>
<h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p>老年代一般不使用复制算法，而是标记-整理算法。</p>
<p>标记过程如前所述，而整理则是将所有存活对象向一端移动，再清理掉端边界以外的内存。</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1570523642697.png">
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>一般老年代使用标记-清除或标记-整理，而新生代使用复制算法。</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>枚举根节点需要停顿所有Java线程。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>程序执行时，只有到达安全点才可以GC。</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>程序没有分配cpu时间时，即程序没有执行时，需要安全区域来解决GC问题（此时安全点失效）。</p>
<p>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>垃圾收集算法是内存回收的方法论，垃圾收集器是内存回收的具体实现。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>最基本、发展历史最悠久的收集器。</p>
<p>单线程、新生代。优点：简单而高效。</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1570605698632.png">
<p>是<strong>client模式</strong>下的默认新生代收集器。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>Serial收集器的多线程版本。</p>
<p>除多线程外，与Serial收集器基本相同。</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1570606028792.png">
<p>是许多<strong>Server模式</strong>下虚拟机的首选新生代收集器。其中一个重要原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p>
<p><strong>注：</strong> 垃圾收集器语境下的并发和并行解释：</p>
<ul>
<li>并行：多条垃圾收集器线程并行工作，此时用户线程仍处于等待状态。</li>
<li>并发：用户线程与垃圾收集器同时执行。</li>
</ul>
<h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>新生代、复制算法、并行。</p>
<p>不同：Parallel Scavenge的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制的吞吐量。</p>
<p>Parallel Scavenge收集器被称为“吞吐量优先”收集器。</p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>Serial收集器的老年代版本。</p>
<p>主要意义在于给Client模式下的虚拟机使用。在Server模式下，主要还有两大用途：一种是在JDK 1.5以及之前的版本中与Parallel Scavenge 收集器搭配使用，另一种是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1570606950976.png">
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>Parallel Scavenge的老年代版本。</p>
<p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1570607165870.png">
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>以获取最短回收停顿时间为目标。并发收集、低停顿·。</p>
<p>基于“Mark-Sweep”算法，一共四个阶段：</p>
<ul>
<li><p>初始标记（CMS initial mark） </p>
<p>标记GC Roots能之间关联到的对象，速度很快。</p>
</li>
<li><p>并发标记（CMS concurrent mark） </p>
<p>进行GC Roots Tracing过程。</p>
</li>
<li><p>重新标记（CMS remark） </p>
<p>修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 </p>
</li>
<li><p>并发清除（CMS concurrent sweep） </p>
</li>
</ul>
<p>初始标记与重新标记需要“Stop The World”。</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1570607480233.png">
<p>尽管已经很优秀了，CMS收集器仍然有3个明显缺点：</p>
<ul>
<li><p>对CPU资源非常敏感。</p>
</li>
<li><p>无法处理浮动垃圾</p>
<p>可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。并发清理时用户线程产生的垃圾称为“浮动垃圾”，只能在下次垃圾收集时再清除。</p>
</li>
<li><p>空间碎片问题</p>
<p>此问题来源于Mark-Sweep算法</p>
</li>
</ul>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>G1(Garbage-First)面向服务端应用的收集器。</p>
<p>特点如下：</p>
<ul>
<li><p>并行与并发</p>
<p>G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。 </p>
</li>
<li><p>分代收集</p>
<p>不要其他收集器配合，独立管理整个GC堆。</p>
</li>
<li><p>空间整合</p>
<p>整体基于Mark-Compact，局部基于copying，不会产生内存空间碎片。</p>
</li>
<li><p>可预测的停顿</p>
<p>这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 </p>
</li>
</ul>
<p>G1将整个Java堆划分为多个大小相等的独立区域（Region）。G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<p>Region不可能是独立的，一个对象被分到Region中，也可能被其他区域的对象引用。为了避免全堆扫描，使用Remembered Set来记录引用信息（每个Region一个）。</p>
<p>不计算维护Remembered Set的操作，G1收集器的运作可划分为以下步骤：</p>
<ul>
<li><p>初始标记</p>
</li>
<li><p>并发标记</p>
</li>
<li><p>最终标记</p>
</li>
<li><p>筛选回收</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1570609405994.png">
<p>​</p>
</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象优先在Eden分配</p>
<p>大对象直接进入老年代（写代码时注意尽量不要朝生夕灭）</p>
<p>长期存活的对象进入老年代（使用Age计数器标记）</p>
<p>动态对象年龄判断：若Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><p>字节码是构成平台无关性的基石，Java虚拟机也提供语言无关性。</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1571020555905.png">
<h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。 </p>
<p>根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。</p>
<p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。 </p>
<img src="/2020/01/10/深入理解JVM读书笔记/1571020703366.png">
<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><img src="/2020/01/10/深入理解JVM读书笔记/1571034765227.png">
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3 </p>
<p>部分统称为连接（Linking）</p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>
<p>虚拟机规范严格规定了<strong>有且只有</strong>5种情况必须立即对类进行“初始化”（而加载、验证、准备需要在此之前开始）： </p>
<ul>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。（常见使用场景：使用new关键字实例化对象时，读取或设置一个类的静态字段（被final修饰，已在编译期放入长两次的静态字段除外），以及调用一个类的静态方法时。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 </li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。 </li>
<li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ul>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机需要完成以下3件事情：</p>
<ul>
<li>通过一个类的全限定名来获取此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<p>相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，可以自定义自己的类加载器。</p>
<p><strong>数组本身不通过类加载器创建，它是由Java虚拟机直接创建的</strong></p>
<p>一个数组类的创建过程遵循以下规则：</p>
<ul>
<li>如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。</li>
<li>如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。</li>
</ul>
<p>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。</p>
<p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的， 加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 </p>
<p>验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点： </p>
<p>是否以魔数0xCAFEBABE开头。 </p>
<p>主、次版本号是否在当前虚拟机处理范围之内。 </p>
<p>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 </p>
<p>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 </p>
<p>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。 </p>
<p>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</p>
<p>……（省略）</p>
<p>这阶段的验证是基于二进制字节流进行的，后面的验证不会再直接操作字节流。</p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下： </p>
<p>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。 </p>
<p>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。 </p>
<p>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</p>
<p>……</p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如： </p>
<p>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。</p>
<p>保证跳转指令不会跳转到方法体以外的字节码指令上。 </p>
<p>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。 </p>
<p>……</p>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容： </p>
<p>符号引用中通过字符串描述的全限定名是否能找到对应的类。 </p>
<p>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。 </p>
<p>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。 </p>
<p>……</p>
<p>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p>
<p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对程序运行期没有影响）的阶段。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p>这时候进行内存分配的仅包括<strong>类变量</strong>（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<p>假设一个类变量的定义为： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>；</span><br></pre></td></tr></table></figure>
<p>则准备阶段后value的值为0（若有final修饰符，则为123，因为123已在常量表中）</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1571038131082.png">
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 </p>
<p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
<p>虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield和putstatic这16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
<p>除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存，避免解析动作重复进行。</p>
<p>由于invokedynamic指令的目的是用于动态语言支持，等运行到当前指令时，再进行解析动作。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化阶段是类加载过程的最后一步。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。</p>
<p>初始化阶段是执行类构造器＜clinit＞（）方法的过程。</p>
<p>＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}块）中的语句合并产生的。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从Java虚拟机的角度来看，只存在两种不同的类加载器：</p>
<ul>
<li><p>启动类加载器</p>
<p>由C++语言实现，是虚拟机的一部分</p>
</li>
<li><p>所有其他的类加载器</p>
<p>都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader</p>
</li>
</ul>
<p>从开发人员角度来看，有三种类加载器：</p>
<ul>
<li><p>启动类加载器</p>
<p>负责加载放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库</p>
</li>
<li><p>扩展类加载器</p>
<p>由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库</p>
</li>
<li><p>应用程序类加载器</p>
<p>器由sun.misc.Launcher $App- ClassLoader实现，负责加载用户类路径（ClassPath）上所指定的类库</p>
<img src="/2020/01/10/深入理解JVM读书笔记/1571902123343.png">
<p>​</p>
</li>
</ul>
<p>上图称为类加载器的双亲委派模型。</p>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/26/Android开发艺术探索笔记系列-第4章-View的工作原理/" rel="next" title="Android开发艺术探索笔记系列-第4章-View的工作原理">
                <i class="fa fa-chevron-left"></i> Android开发艺术探索笔记系列-第4章-View的工作原理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="WCXDHR" />
            
              <p class="site-author-name" itemprop="name">WCXDHR</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java内存区域与内存溢出异常"><span class="nav-number">1.</span> <span class="nav-text">Java内存区域与内存溢出异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时数据区域"><span class="nav-number">1.1.</span> <span class="nav-text">运行时数据区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器"><span class="nav-number">1.1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java虚拟机栈"><span class="nav-number">1.1.2.</span> <span class="nav-text">Java虚拟机栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地方法栈"><span class="nav-number">1.1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java堆"><span class="nav-number">1.1.4.</span> <span class="nav-text">Java堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区"><span class="nav-number">1.1.5.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时常量池"><span class="nav-number">1.1.6.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接内存"><span class="nav-number">1.1.7.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HotSpot虚拟机对象探秘"><span class="nav-number">1.2.</span> <span class="nav-text">HotSpot虚拟机对象探秘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的创建"><span class="nav-number">1.2.1.</span> <span class="nav-text">对象的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">1.2.2.</span> <span class="nav-text">对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象头"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例数据"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">实例数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对齐填充"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">对齐填充</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的访问定位"><span class="nav-number">1.2.3.</span> <span class="nav-text">对象的访问定位</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾收集器与内存分配策略"><span class="nav-number">2.</span> <span class="nav-text">垃圾收集器与内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#判断对象是否死去"><span class="nav-number">2.1.</span> <span class="nav-text">判断对象是否死去</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数算法"><span class="nav-number">2.1.1.</span> <span class="nav-text">引用计数算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可达性分析算法"><span class="nav-number">2.1.2.</span> <span class="nav-text">可达性分析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#再谈引用"><span class="nav-number">2.1.3.</span> <span class="nav-text">再谈引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生存还是死亡"><span class="nav-number">2.1.4.</span> <span class="nav-text">生存还是死亡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回收方法区"><span class="nav-number">2.1.5.</span> <span class="nav-text">回收方法区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集算法"><span class="nav-number">2.2.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-清除算法（Mark-Sweep"><span class="nav-number">2.2.1.</span> <span class="nav-text">标记-清除算法（Mark-Sweep)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制算法（Copying）"><span class="nav-number">2.2.2.</span> <span class="nav-text">复制算法（Copying）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-整理算法（Mark-Compact）"><span class="nav-number">2.2.3.</span> <span class="nav-text">标记-整理算法（Mark-Compact）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集算法"><span class="nav-number">2.2.4.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HotSpot的算法实现"><span class="nav-number">2.3.</span> <span class="nav-text">HotSpot的算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举根节点"><span class="nav-number">2.3.1.</span> <span class="nav-text">枚举根节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全点"><span class="nav-number">2.3.2.</span> <span class="nav-text">安全点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全区域"><span class="nav-number">2.3.3.</span> <span class="nav-text">安全区域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">2.4.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial收集器"><span class="nav-number">2.4.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew收集器"><span class="nav-number">2.4.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Scavenge-收集器"><span class="nav-number">2.4.3.</span> <span class="nav-text">Parallel Scavenge 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-Old-收集器"><span class="nav-number">2.4.4.</span> <span class="nav-text">Serial Old 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Old-收集器"><span class="nav-number">2.4.5.</span> <span class="nav-text">Parallel Old 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS-收集器"><span class="nav-number">2.4.6.</span> <span class="nav-text">CMS 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1-收集器"><span class="nav-number">2.4.7.</span> <span class="nav-text">G1 收集器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配与回收策略"><span class="nav-number">2.5.</span> <span class="nav-text">内存分配与回收策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类文件结构"><span class="nav-number">3.</span> <span class="nav-text">类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#无关性的基石"><span class="nav-number">3.1.</span> <span class="nav-text">无关性的基石</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class文件结构"><span class="nav-number">3.2.</span> <span class="nav-text">Class文件结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机类加载机制"><span class="nav-number">4.</span> <span class="nav-text">虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载时机"><span class="nav-number">4.1.</span> <span class="nav-text">类加载时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载过程"><span class="nav-number">4.2.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载"><span class="nav-number">4.2.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证"><span class="nav-number">4.2.2.</span> <span class="nav-text">验证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件格式验证"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">文件格式验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#元数据验证"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">元数据验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字节码验证"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">字节码验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#符号引用验证"><span class="nav-number">4.2.2.4.</span> <span class="nav-text">符号引用验证</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备"><span class="nav-number">4.2.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析"><span class="nav-number">4.2.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">4.2.5.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器"><span class="nav-number">4.3.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类与类加载器"><span class="nav-number">4.3.1.</span> <span class="nav-text">类与类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">4.3.2.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WCXDHR</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">21k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
