<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WCXDHR Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wcxdhr.github.io/"/>
  <updated>2020-01-10T03:27:58.224Z</updated>
  <id>https://wcxdhr.github.io/</id>
  
  <author>
    <name>WCXDHR</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解JVM读书笔记</title>
    <link href="https://wcxdhr.github.io/2020/01/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://wcxdhr.github.io/2020/01/10/深入理解JVM读书笔记/</id>
    <published>2020-01-10T03:13:17.000Z</published>
    <updated>2020-01-10T03:27:58.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><img src="/2020/01/10/深入理解JVM读书笔记/1569306828310.png"><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>一块较小的内存空间，可以看作当前线程所执行字节码的行号执行器。</p><p>Java虚拟机规范中唯一未规定任何<strong>OutOfMemoryError</strong>的情况的区域。<a id="more"></a></p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>线程私有，与线程的生命周期相同。描述Java方法执行的内存模型：每个方法在运行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应着从入栈到出栈的过程。</p><p><strong>注</strong>：通常把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，这里所指的“栈”就是虚拟机栈，或虚拟机栈中局部变量表的地方。</p><p><strong>两种异常</strong>：</p><ul><li><p>StackOverflowError </p><p>线程请求的栈深度大于虚拟机所允许的深度。</p></li><li><p>OutOfMemoryError</p><p>（若虚拟可以动态扩展）扩展时无法申请到足够的内存</p></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈类似，不过为Native方法服务，部分虚拟机（例如Sun HotSpot）直接将两者合一。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>线程共享，存放对象实例，几乎所有的对象实例都要在堆上分配内存。</p><p>Java堆是垃圾收集器管理的主要区域。</p><p>物理上可以不连续，逻辑上连续即可。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。过去，方法区被称为“永久代”（涉及分代收集算法，按照对象的生命周期进行划分，使用不同的垃圾回收算法）</p><p>Java虚拟机规范对方法区限制十分宽松，除和Java堆一样不需要连续内存和可以选择固定大小或者可扩展外，可以选择不实现垃圾收集。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行常量池（Runtime Constant Pool）是<strong>方法区</strong>的一部分。用于存放Class文件中的常量池（Constant Pool Table）（存放编译期生成的各种字面量和符号引用）。</p><p>运行时常量池具有动态性，运行时可以将新的常量放入池中。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>本机直接分配的内存，受到本机总内存的限制。</p><h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ul><li>虚拟机遇到一条new指令，首先检查指令参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。若没有，则必须先执行类加载过程。</li><li>类加载通过后，为新生对象分配内存，分配的内存大小在类加载后便完全确定。内存分配时，一般有指针碰撞（内存规整）和空闲列表（内存相互交错）。Java堆是否规整由采用的垃圾收集器是否带有压缩整理功能决定。分配内存时还有线程安全问题，解决方法有两种：一是对分配动作继续同步处理，二是为每个线程在堆上预先分配一小块内存——本地线程分配缓冲（TLAB），只有TLAB用完分配新的TLAB时需要同步锁定。</li><li>内存分配完后，虚拟机将分配到的内存空间都初始化为零值。</li><li>接下来，对对象进行必要的设置，例如对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存储在<strong>对象头</strong>中。</li><li>上面工作完成后，虚拟机视角的新对象已经产生，但Java程序视角对象才刚刚开始创建，接下来执行<init> 方法。</init></li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充。</p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>对象头分为两部分：</p><ul><li>用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等等，官方称为“Mark Word”。</li><li>类型指针，即对象指向它的类元数据的指针（并不是所有的虚拟机实现都必须保留类型指针。</li></ul><p>另外，若对象是数组，则对象头中还必须有一块用于记录数组长度。</p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>对象真正存储的有效信息，存储顺序受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>不是必要存在，要求对象长度必须是8字节的整数倍。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。</p><p>主流对象访问方式有两种：</p><ul><li><p>句柄访问</p><img src="/2020/01/10/深入理解JVM读书笔记/1569311242265.png"><p>​</p></li><li><p>直接指针访问</p><img src="/2020/01/10/深入理解JVM读书笔记/1569311296712.png"><p>​</p></li></ul><p>句柄的优点：reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p><p>直接指针的优点：速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p><h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="判断对象是否死去"><a href="#判断对象是否死去" class="headerlink" title="判断对象是否死去"></a>判断对象是否死去</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象添加一个引用计数器，计数为0的对象则不再使用。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>主流商用语言（Java、c#等）的主流实现中，通过可达性分析来判定对象是否存活。</p><p>基本思想：从GC Roots的对象开始往下搜索，走过的路径称为引用链，当一个对象到GC Roots没有任何引用链，则从GC Roots到这个对象不可达，对象不可用。</p><img src="/2020/01/10/深入理解JVM读书笔记/1570519830535.png"><p><strong>注</strong>：Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>JDK1.2之后，Java对引用的概念进行了补充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p><ul><li>强引用：普遍存在，例如new方法。存在时垃圾收集器不会回收。</li><li>软引用：用来描述一些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回 收还没有足够的内存，才会抛出内存溢出异常。</li><li>弱引用：描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾收集之前。</li><li>虚引用：也称幽灵引用或者幻影引用。它是最弱的一种引用关系。一个对象是否有虚引 用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一 个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>可达性分析后不可达的对象，并非“非死不可”。</p><p>真正宣告一个对象死亡，至少经历两次标记过程：</p><ul><li>可达性分析后进行第一次标记并筛选对象是否需要执行finalize（）方法。当对象没有覆盖finalize（）方法，或 者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</li><li>执行finalize（）方法时若重新建立引用连接，则第二次标记时移除出回收集合，否则对象将被回收。</li></ul><p><strong>注：</strong>任何对象的finalize（）方法只能被系统调用一次。（建议不要使用该方法）</p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区（永久代）的垃圾回收包括两部分：废弃常量和无用的类。</p><p>判断一个常量是否废弃比较简单，而判定一个类是否无用则需要满足以下条件：</p><ul><li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</p></li><li><p>加载该类的ClassLoader已经被回收。 </p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该 </p><p>类的方法。 </p></li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法（Mark-Sweep"><a href="#标记-清除算法（Mark-Sweep" class="headerlink" title="标记-清除算法（Mark-Sweep)"></a>标记-清除算法（Mark-Sweep)</h3><p>分为标记和清楚两部分。</p><p>法如其名。（标记方法如前所述）</p><p>主要不足：</p><ul><li><p>效率问题：标记和清楚过程的效率不高</p></li><li><p>空间问题：清除后产生大量不连续的内存碎片，可能导致以后下次分配大对象时无连续可用内存而再次触发垃圾收集。</p><img src="/2020/01/10/深入理解JVM读书笔记/1570522647752.png"><p>​</p></li></ul><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p>为了解决效率问题。</p><p>将内存按容量分为大小相等的两块，每次只使用其中一块，当这一块内存用完，则将还存活的对象复制到另一半中，将这一块一次清理掉。不用考虑碎片问题，实现简单，运行高效。</p><p>算法代价太高，将内存直接减半。</p><img src="/2020/01/10/深入理解JVM读书笔记/1570523031280.png"><p>现在的商用虚拟机都采用这种算法来回收<strong>新生代</strong>，由于新生代中对象98%是“朝生夕死”的，不需要按照1：1来分配空间。而是将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。回收时，Eden和Survivor中的存活对象复制到另一块Survivor中，再一次清理掉刚才的空间。HotSpot中默认Eden：Survivor为8：1。（当Survivor不够时，需要依赖老年代进行分配担保）</p><h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p>老年代一般不使用复制算法，而是标记-整理算法。</p><p>标记过程如前所述，而整理则是将所有存活对象向一端移动，再清理掉端边界以外的内存。</p><img src="/2020/01/10/深入理解JVM读书笔记/1570523642697.png"><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>一般老年代使用标记-清除或标记-整理，而新生代使用复制算法。</p><h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>枚举根节点需要停顿所有Java线程。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>程序执行时，只有到达安全点才可以GC。</p><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>程序没有分配cpu时间时，即程序没有执行时，需要安全区域来解决GC问题（此时安全点失效）。</p><p>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>垃圾收集算法是内存回收的方法论，垃圾收集器是内存回收的具体实现。</p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>最基本、发展历史最悠久的收集器。</p><p>单线程、新生代。优点：简单而高效。</p><img src="/2020/01/10/深入理解JVM读书笔记/1570605698632.png"><p>是<strong>client模式</strong>下的默认新生代收集器。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>Serial收集器的多线程版本。</p><p>除多线程外，与Serial收集器基本相同。</p><img src="/2020/01/10/深入理解JVM读书笔记/1570606028792.png"><p>是许多<strong>Server模式</strong>下虚拟机的首选新生代收集器。其中一个重要原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><p><strong>注：</strong> 垃圾收集器语境下的并发和并行解释：</p><ul><li>并行：多条垃圾收集器线程并行工作，此时用户线程仍处于等待状态。</li><li>并发：用户线程与垃圾收集器同时执行。</li></ul><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>新生代、复制算法、并行。</p><p>不同：Parallel Scavenge的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制的吞吐量。</p><p>Parallel Scavenge收集器被称为“吞吐量优先”收集器。</p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>Serial收集器的老年代版本。</p><p>主要意义在于给Client模式下的虚拟机使用。在Server模式下，主要还有两大用途：一种是在JDK 1.5以及之前的版本中与Parallel Scavenge 收集器搭配使用，另一种是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p><img src="/2020/01/10/深入理解JVM读书笔记/1570606950976.png"><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>Parallel Scavenge的老年代版本。</p><p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p><img src="/2020/01/10/深入理解JVM读书笔记/1570607165870.png"><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>以获取最短回收停顿时间为目标。并发收集、低停顿·。</p><p>基于“Mark-Sweep”算法，一共四个阶段：</p><ul><li><p>初始标记（CMS initial mark） </p><p>标记GC Roots能之间关联到的对象，速度很快。</p></li><li><p>并发标记（CMS concurrent mark） </p><p>进行GC Roots Tracing过程。</p></li><li><p>重新标记（CMS remark） </p><p>修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 </p></li><li><p>并发清除（CMS concurrent sweep） </p></li></ul><p>初始标记与重新标记需要“Stop The World”。</p><img src="/2020/01/10/深入理解JVM读书笔记/1570607480233.png"><p>尽管已经很优秀了，CMS收集器仍然有3个明显缺点：</p><ul><li><p>对CPU资源非常敏感。</p></li><li><p>无法处理浮动垃圾</p><p>可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。并发清理时用户线程产生的垃圾称为“浮动垃圾”，只能在下次垃圾收集时再清除。</p></li><li><p>空间碎片问题</p><p>此问题来源于Mark-Sweep算法</p></li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>G1(Garbage-First)面向服务端应用的收集器。</p><p>特点如下：</p><ul><li><p>并行与并发</p><p>G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。 </p></li><li><p>分代收集</p><p>不要其他收集器配合，独立管理整个GC堆。</p></li><li><p>空间整合</p><p>整体基于Mark-Compact，局部基于copying，不会产生内存空间碎片。</p></li><li><p>可预测的停顿</p><p>这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 </p></li></ul><p>G1将整个Java堆划分为多个大小相等的独立区域（Region）。G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>Region不可能是独立的，一个对象被分到Region中，也可能被其他区域的对象引用。为了避免全堆扫描，使用Remembered Set来记录引用信息（每个Region一个）。</p><p>不计算维护Remembered Set的操作，G1收集器的运作可划分为以下步骤：</p><ul><li><p>初始标记</p></li><li><p>并发标记</p></li><li><p>最终标记</p></li><li><p>筛选回收</p><img src="/2020/01/10/深入理解JVM读书笔记/1570609405994.png"><p>​</p></li></ul><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象优先在Eden分配</p><p>大对象直接进入老年代（写代码时注意尽量不要朝生夕灭）</p><p>长期存活的对象进入老年代（使用Age计数器标记）</p><p>动态对象年龄判断：若Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><p>字节码是构成平台无关性的基石，Java虚拟机也提供语言无关性。</p><img src="/2020/01/10/深入理解JVM读书笔记/1571020555905.png"><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。 </p><p>根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。</p><p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。 </p><img src="/2020/01/10/深入理解JVM读书笔记/1571020703366.png"><h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><img src="/2020/01/10/深入理解JVM读书笔记/1571034765227.png"><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3 </p><p>部分统称为连接（Linking）</p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p><p>虚拟机规范严格规定了<strong>有且只有</strong>5种情况必须立即对类进行“初始化”（而加载、验证、准备需要在此之前开始）： </p><ul><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。（常见使用场景：使用new关键字实例化对象时，读取或设置一个类的静态字段（被final修饰，已在编译期放入长两次的静态字段除外），以及调用一个类的静态方法时。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 </li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。 </li><li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机需要完成以下3件事情：</p><ul><li>通过一个类的全限定名来获取此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，可以自定义自己的类加载器。</p><p><strong>数组本身不通过类加载器创建，它是由Java虚拟机直接创建的</strong></p><p>一个数组类的创建过程遵循以下规则：</p><ul><li>如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。</li><li>如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。</li></ul><p>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。</p><p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的， 加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 </p><p>验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点： </p><p>是否以魔数0xCAFEBABE开头。 </p><p>主、次版本号是否在当前虚拟机处理范围之内。 </p><p>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 </p><p>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 </p><p>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。 </p><p>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</p><p>……（省略）</p><p>这阶段的验证是基于二进制字节流进行的，后面的验证不会再直接操作字节流。</p><h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下： </p><p>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。 </p><p>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。 </p><p>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</p><p>……</p><h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如： </p><p>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。</p><p>保证跳转指令不会跳转到方法体以外的字节码指令上。 </p><p>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。 </p><p>……</p><h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容： </p><p>符号引用中通过字符串描述的全限定名是否能找到对应的类。 </p><p>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。 </p><p>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。 </p><p>……</p><p>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p><p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对程序运行期没有影响）的阶段。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p><p>这时候进行内存分配的仅包括<strong>类变量</strong>（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><p>假设一个类变量的定义为： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>；</span><br></pre></td></tr></table></figure><p>则准备阶段后value的值为0（若有final修饰符，则为123，因为123已在常量表中）</p><img src="/2020/01/10/深入理解JVM读书笔记/1571038131082.png"><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 </p><p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</p><p>虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield和putstatic这16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p><p>除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存，避免解析动作重复进行。</p><p>由于invokedynamic指令的目的是用于动态语言支持，等运行到当前指令时，再进行解析动作。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化阶段是类加载过程的最后一步。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。</p><p>初始化阶段是执行类构造器＜clinit＞（）方法的过程。</p><p>＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}块）中的语句合并产生的。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从Java虚拟机的角度来看，只存在两种不同的类加载器：</p><ul><li><p>启动类加载器</p><p>由C++语言实现，是虚拟机的一部分</p></li><li><p>所有其他的类加载器</p><p>都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader</p></li></ul><p>从开发人员角度来看，有三种类加载器：</p><ul><li><p>启动类加载器</p><p>负责加载放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库</p></li><li><p>扩展类加载器</p><p>由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库</p></li><li><p>应用程序类加载器</p><p>器由sun.misc.Launcher $App- ClassLoader实现，负责加载用户类路径（ClassPath）上所指定的类库</p><img src="/2020/01/10/深入理解JVM读书笔记/1571902123343.png"><p>​</p></li></ul><p>上图称为类加载器的双亲委派模型。</p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><p>使用双亲委派模型来组织类加载器之间的关系，好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存区域与内存溢出异常&quot;&gt;&lt;a href=&quot;#Java内存区域与内存溢出异常&quot; class=&quot;headerlink&quot; title=&quot;Java内存区域与内存溢出异常&quot;&gt;&lt;/a&gt;Java内存区域与内存溢出异常&lt;/h1&gt;&lt;img src=&quot;/2020/01/10/深入理解JVM读书笔记/1569306828310.png&quot;&gt;
&lt;h2 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h2&gt;&lt;h3 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h3&gt;&lt;p&gt;一块较小的内存空间，可以看作当前线程所执行字节码的行号执行器。&lt;/p&gt;
&lt;p&gt;Java虚拟机规范中唯一未规定任何&lt;strong&gt;OutOfMemoryError&lt;/strong&gt;的情况的区域。
    
    </summary>
    
      <category term="深入理解JVM笔记" scheme="https://wcxdhr.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索笔记系列-第4章-View的工作原理</title>
    <link href="https://wcxdhr.github.io/2019/06/26/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://wcxdhr.github.io/2019/06/26/Android开发艺术探索笔记系列-第4章-View的工作原理/</id>
    <published>2019-06-26T08:34:58.000Z</published>
    <updated>2019-06-26T08:39:06.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="View的工作原理"><a href="#View的工作原理" class="headerlink" title="View的工作原理"></a>View的工作原理</h1><h2 id="初识ViewRoot和DecorView"><a href="#初识ViewRoot和DecorView" class="headerlink" title="初识ViewRoot和DecorView"></a>初识ViewRoot和DecorView</h2><p>ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联<a id="more"></a>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">root.setView(view, wparams, panelParentView);</span><br></pre></td></tr></table></figure><p>View的绘制流程都是从ViewRoot的performTraversals方法开始的，它经过measure、layout和draw三个过程才能将一个View绘制出来。</p><table><thead><tr><th>过程</th><th>作用</th></tr></thead><tbody><tr><td>measure</td><td>测量View的宽和高；完成后可以通过getMeasureWidth和getMeasureHeight方法来获取View测量后的宽和高</td></tr><tr><td>layout</td><td>确定View在父容器中的放置位置；决定了View四个顶点的坐标和实际的View的宽/高；完成后可以通过getTop、getButton、getLeft和getRight来拿到四个顶点的位置，并通过getWidth和getHeight拿到View的最终宽/高</td></tr><tr><td>draw</td><td>负责将View绘制在屏幕上</td></tr></tbody></table><img src="/2019/06/26/Android开发艺术探索笔记系列-第4章-View的工作原理/1561447542773.png"><p>如图所示，performTraversals会依次调用performMeasure、performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure、layout和draw这三大流程，其中在performMeasure中会调用measure方法，在measure中会调用onMeasure，在onMeasure中又会对所有子元素进行measure过程，以此完成整个View树的遍历。另外两个类似。</p><img src="/2019/06/26/Android开发艺术探索笔记系列-第4章-View的工作原理/1561448233938.png"><p>如图所示，在Activity中通过setContentView所设置的布局文件是被加入到下面的内容栏中。</p><h2 id="理解MeasureSpec"><a href="#理解MeasureSpec" class="headerlink" title="理解MeasureSpec"></a>理解MeasureSpec</h2><p>MeasureSpec很大程度上决定了一个View的尺寸规格（还受父容器的影响）。</p><h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>MeasureSpec代表一个32位int值，高2位代表SpecMode（测量模式），低30位代表SpecSize（规格大小）。</p><p>SpecMode有三类：</p><ul><li><p>UNSPECIFIED</p><p>父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。</p></li><li><p>EXACTLY</p><p>父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式。</p></li><li><p>AT_MOST</p><p>父容器制定了一个可用大小即SpecSize，View的大小不能大于这个值，具体是什么值要看不同View的具体实现。它对应于LayoutParams中的wrap_content。</p></li></ul><h3 id="MeasureSpec和LayoutParams的对应关系"><a href="#MeasureSpec和LayoutParams的对应关系" class="headerlink" title="MeasureSpec和LayoutParams的对应关系"></a>MeasureSpec和LayoutParams的对应关系</h3><p>系统会根据LayoutParams在父容器的约束下转换成对应的MeasureSpec。</p><p>对于DecorView来说，MeasureSpec遵守如下规则：</p><ul><li>LayoutParams.MATCH_PARENT：精确模式，大小就是窗口的大小；</li><li>LayoutParams.WRAP_CONTENT：最大模式，大小不定，但不能超过窗口的大小；</li><li>固定大小：精确模式，大小位LayoutParams中指定的大小。</li></ul><p>对于普通View来说，子元素的MeasureSpec的创建与父容器的MeasureSpec和子元素本身的LayoutParams有关，如图：</p><img src="/2019/06/26/Android开发艺术探索笔记系列-第4章-View的工作原理/1561451286724.png"><h2 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a>View的工作流程</h2><h3 id="measure过程"><a href="#measure过程" class="headerlink" title="measure过程"></a>measure过程</h3><p><strong>View的measure过程</strong></p><p>由View的measure方法完成，measure方法中调用onMeasure方法。</p><p><strong>ViewGroup的measure过程</strong></p><p>除了完成自己的measure过程外，还会遍历去调用所有子元素的measure方法，各子元素再递归执行这个过程。和View不同，ViewGoup是一个抽象类，没有重写omMeasure方法，而是提供了measureChildren的方法。</p><p><strong>具体分析略</strong></p><p><strong>在Activity已启动后获取某个View的宽/高</strong></p><ul><li><p>Activity/View#onWindowFocusChanged</p><p>当Activity的窗口得到焦点和失去焦点时均会被调用一次（当Activity继续执行和暂停执行时，onWindowFocusChanged均会被调用。</p><p>典型代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">    <span class="keyword">if</span> (hsaFocus) &#123;</span><br><span class="line">        <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">        <span class="keyword">int</span> height = view.getMeasuredHeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>view.post(runnable)</p><p>通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，View也已经初始化好了。</p><p>典型代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    view.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">int</span> height = view.getMeasuredHeight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ViewTreeObserver</p><p>使用ViewTreeObserver的众多回调可以完成这个功能，如OnGlobalLayoutListener这个接口，当View树的状态发生改变或者View树内部的View的可见性发生改变时，onGlobalLayout方法将被回调。</p><p>典型代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    </span><br><span class="line">    ViewTreeObserver observer = view.getViewTreeObserver();</span><br><span class="line">    observer.addOnGlobalLayoutListener(<span class="keyword">new</span> OnGlobalLayoutListener() &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            view.getViewTreeObeserver().removeGlobalOnLayoutListener(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">int</span> height = view.getMeasuredHeight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>view.measure(int widthMeasureSpec, int heightMeasureSpec)</p><p>通过手动对View进行measure来得到View的宽/高。这种方法比较复杂，这里要分情况处理，根据View的LayoutParams来分，具体省略。</p></li></ul><h3 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h3><p>省略</p><h3 id="draw过程"><a href="#draw过程" class="headerlink" title="draw过程"></a>draw过程</h3><ul><li>绘制背景backgroud.draw(canvas)</li><li>绘制自己(onDraw)</li><li>绘制children(dispatchDraw)</li><li>绘制装饰(onDrawScrollBars)</li></ul><h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><h3 id="自定义View分类"><a href="#自定义View分类" class="headerlink" title="自定义View分类"></a>自定义View分类</h3><ul><li><p>继承View重写onDraw方法</p><p>主要用于实现一些不规则的效果，需要重写onDraw方法，自己支持wrap_content，处理padding。</p></li><li><p>继承ViewGroup派生特殊的Layout</p><p>主要用于实现自定义布局，比较复杂。</p></li><li><p>继承特殊的View（比如TextView）</p><p>扩展某种已有的View的功能，较容易实现，不需要自己支持wrap_content，处理padding。</p></li><li><p>继承特定的ViewGroup（比如LinearLayout）</p><p>当某种效果看起来很像几种View组合在一起的时候，可以采用这种方式来实现。</p></li></ul><h3 id="自定义View须知"><a href="#自定义View须知" class="headerlink" title="自定义View须知"></a>自定义View须知</h3><ul><li><p>让View支持wrap_content</p><p>对于直接继承View和ViewGroup的控件来说。</p></li><li><p>如果有必要，让你的View支持padding</p><p>对于直接继承View和ViewGroup的控件来说。</p></li><li><p>尽量不要在View中使用Handler</p><p>View内部提供了post系列的方法，替代Handler。</p></li><li><p>View中如果有线程或者动画，需要及时停止，参考View#onDetachedFromWindow</p></li><li><p>View带有滑动嵌套情形时，需要处理好滑动冲突</p></li></ul><h3 id="自定义View示例"><a href="#自定义View示例" class="headerlink" title="自定义View示例"></a>自定义View示例</h3><p><strong>自定义属性</strong></p><p>第一步，在values目录下创建自定义属性的XML，比如attrs.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"CircleView"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"circle_color"</span> <span class="attr">format</span>=<span class="string">"color"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步，在View的构造方法中解析自定义属性的值并做相应处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CircleView);</span><br><span class="line">    mColor = a.getColor(R.styleable.CircleView_circle_color, Color.RED);</span><br><span class="line">    a.recycle();</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，在布局文件中使用自定义属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">....</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">...</span></span></span><br><span class="line"><span class="tag">           &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.....</span></span></span><br><span class="line"><span class="tag">              <span class="attr">...</span></span></span><br><span class="line"><span class="tag">              <span class="attr">app:circle_color</span>=<span class="string">"@color/light_green"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">...</span></span></span><br><span class="line"><span class="tag">              /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;View的工作原理&quot;&gt;&lt;a href=&quot;#View的工作原理&quot; class=&quot;headerlink&quot; title=&quot;View的工作原理&quot;&gt;&lt;/a&gt;View的工作原理&lt;/h1&gt;&lt;h2 id=&quot;初识ViewRoot和DecorView&quot;&gt;&lt;a href=&quot;#初识ViewRoot和DecorView&quot; class=&quot;headerlink&quot; title=&quot;初识ViewRoot和DecorView&quot;&gt;&lt;/a&gt;初识ViewRoot和DecorView&lt;/h2&gt;&lt;p&gt;ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联
    
    </summary>
    
      <category term="Android开发艺术探索笔记" scheme="https://wcxdhr.github.io/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索笔记系列-第3章-View的事件体系</title>
    <link href="https://wcxdhr.github.io/2019/05/15/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"/>
    <id>https://wcxdhr.github.io/2019/05/15/Android开发艺术探索笔记系列-第3章-View的事件体系/</id>
    <published>2019-05-15T08:47:40.000Z</published>
    <updated>2019-05-15T08:56:16.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="View的事件体系"><a href="#View的事件体系" class="headerlink" title="View的事件体系"></a>View的事件体系</h1><h2 id="View基础知识"><a href="#View基础知识" class="headerlink" title="View基础知识"></a>View基础知识</h2><h3 id="什么是View"><a href="#什么是View" class="headerlink" title="什么是View"></a>什么是View</h3><p>View是Android中所有控件的基类。</p><p>ViewGroup内部包含了一组View，它也继承自View。这种关系形成了View树的概念。<a id="more"></a></p><h3 id="View的位置参数"><a href="#View的位置参数" class="headerlink" title="View的位置参数"></a>View的位置参数</h3><p>四个属性：</p><ul><li>top 左上角纵坐标</li><li>left 左上角横坐标</li><li>right 右下角横坐标</li><li>bottom 右下角纵坐标</li></ul><p>以上都是相对坐标，相对于父容器来说。</p><p><strong>x轴和y轴方向分别为右和下（第四象限）</strong></p><img src="/2019/05/15/Android开发艺术探索笔记系列-第3章-View的事件体系/1557129414312.png"><p>Android3.0之后，View增加了几个额外参数：</p><ul><li>x 和 y：View左上角坐标</li><li>translationX和translationY：View左上角相对于父容器的偏移量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = left + translationX</span><br><span class="line">y = top + translationY</span><br></pre></td></tr></table></figure><p>View在平移过程中，top和left是原始左上角的位置信息，不会发生改变。translationX/Y是平移距离，x/y是View的左上角位置。</p><p>参考：<a href="https://blog.csdn.net/wxv111/article/details/50901199" target="_blank" rel="noopener">https://blog.csdn.net/wxv111/article/details/50901199</a></p><h3 id="MotionEvent和TouchSlop"><a href="#MotionEvent和TouchSlop" class="headerlink" title="MotionEvent和TouchSlop"></a>MotionEvent和TouchSlop</h3><p><strong>MotionEvent</strong></p><p>手指接触屏幕产生的一系列事件中，有以下典型事件：</p><ul><li>ACTION_DOWN：手指刚接触屏幕</li><li>ACTION_MOVE：手指在屏幕上移动</li><li>ACTION_UP：手指从屏幕上松开的一瞬间</li></ul><p>一次手指触摸屏幕的行为会触发一系列点击事件，考虑以下几种情况：</p><ul><li>点击屏幕后离开松开：DOWN-&gt;UP</li><li>点击屏幕滑动再松开：DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP</li></ul><p>通过MotionEvent对象可以得到点击事件发生的x和y坐标：</p><p>getX/getY返回当前相对于当前View左上角的x和y坐标，getRawX/getRawY返回相对手机屏幕左上角的x和y坐标。</p><p><strong>TouchSlop</strong></p><p>系统所能识别的滑动的最小距离。这是一个常量，和设备有关。</p><p>ViewConfiguration.get(getContext()).getScaledTouchSlop()可以获得这个常量。</p><p>在处理滑动时，可以利用这个常量做一些过滤。</p><p>源码frameworks/base/core/res/res/values/config.xml中可以找到这个常量的定义。</p><h3 id="VelocityTracker、GestureDetector和Scroller"><a href="#VelocityTracker、GestureDetector和Scroller" class="headerlink" title="VelocityTracker、GestureDetector和Scroller"></a>VelocityTracker、GestureDetector和Scroller</h3><p><strong>VelocityTracker</strong></p><p>速度追踪，用于追踪手指在滑动过程中的速度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VelocityTracker velocityTracker = VelocityTracker.obtain();</span><br><span class="line">velocityTracker.addMovement(event);<span class="comment">//在View的onTouchEvent方法中追踪当前单击事件速度</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取当前滑动速度</span></span><br><span class="line">velocityTracker.computeCurrentVelocity(<span class="number">1000</span>);<span class="comment">//获取速度前先计算速度，参数为时间，单位ms</span></span><br><span class="line"><span class="keyword">int</span> xVelocity = (<span class="keyword">int</span>) velocityTracker.getXVelocity();</span><br><span class="line"><span class="keyword">int</span> yVelocity = (<span class="keyword">int</span>) velocityTracker.getYVelocity();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用完成后，回收内存</span></span><br><span class="line">velocityTracker.clear();</span><br><span class="line">velocityTracker.recycle();</span><br></pre></td></tr></table></figure><p><strong>GestureDetector</strong></p><p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。</p><ul><li><p>首先，创建一个GestureDetector对象并实现OnGestureListener接口，根据需要还可以实现其它接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector mGestureDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>);</span><br><span class="line">mGestureDetector.setIsLongpressEnabled(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>接着，接管目标View的onTouchEvent方法，在待监听View的onTouchEvent方法中添加实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> consume = mGestureDetector.onTouchEvent(event);</span><br><span class="line"><span class="keyword">return</span> consume;</span><br></pre></td></tr></table></figure></li></ul><p>详解：<a href="https://www.gcssloop.com/customview/gestruedector" target="_blank" rel="noopener">https://www.gcssloop.com/customview/gestruedector</a></p><p><strong>注</strong>：建议只是监听滑动相关的，在onTouchEvent中实现，如果监听双击行为，使用GestureDetector。</p><p><strong>Scroller</strong></p><p>弹性滑动对象，用于实现View的弹性滑动。（View的scrollTo/scrollBy方法来进行滑动时，过程瞬间完成，没有过渡效果）</p><p>Scroller需要和View的computeScroll方法一起配合使用。</p><h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><h3 id="使用scrollTo-scrollBy"><a href="#使用scrollTo-scrollBy" class="headerlink" title="使用scrollTo/scrollBy"></a>使用scrollTo/scrollBy</h3><p>scrollTo实现了基于所传递参数的绝对滑动。scrollBy调用scrollTo，实现了基于当前位置的相对滑动。</p><p>滑动过程中View有两个属性mScrollX和mScrollY，在滑动过程中，总是等于View的左/上边缘和View内容左/上边缘在水平/竖直方向的距离。</p><p>使用scrollTo和scrollBy时，只能将View的内容滑动，不能将View本身移动。</p><img src="/2019/05/15/Android开发艺术探索笔记系列-第3章-View的事件体系/1557733283447.png"><h3 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h3><p>（View动画省略）</p><p>现在使用属性动画。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(targetView, <span class="string">"translationX"</span>, <span class="number">0</span>, <span class="number">100</span>).setDuration(<span class="number">100</span>).start();</span><br></pre></td></tr></table></figure><h3 id="改变布局参数"><a href="#改变布局参数" class="headerlink" title="改变布局参数"></a>改变布局参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line">MarginLayoutParams params = (MarginLayoutParams)mButton1.getLayoutParams();</span><br><span class="line">params.width += <span class="number">100</span>;</span><br><span class="line">params.leftMargin += <span class="number">100</span>;</span><br><span class="line">mButton.requestLayout();<span class="comment">//或mButton1.setLayoutParams(params);</span></span><br></pre></td></tr></table></figure><h3 id="三种滑动方式对比"><a href="#三种滑动方式对比" class="headerlink" title="三种滑动方式对比"></a>三种滑动方式对比</h3><ul><li><p>使用scrollTo/scrollBy：操作简单，适合对View内容的滑动</p><p>View提供的原生方法，专门用于View的滑动，可以比较方便地实现滑动效果而不影响内部元素的单击事件。缺点：只能滑动View的内容，不能滑动View本身。</p></li><li><p>使用动画：操作简单，适用于没有交互的View和实现复杂的动画效果</p><p>属性动画没有明显缺点。优点是一些复杂的效果必须通过动画实现。</p></li><li><p>改变布局参数：操作稍微复杂，适用于有交互的View</p><p>使用起来比较麻烦，也没有明显缺点。主要适用对象是一些具有交互性的View。</p></li></ul><h2 id="弹性滑动"><a href="#弹性滑动" class="headerlink" title="弹性滑动"></a>弹性滑动</h2><p>渐进式滑动，实现方法的共同思想是：将一次大的滑动分成若干次小的滑动并在一个时间段内完成。</p><h3 id="使用Scroller"><a href="#使用Scroller" class="headerlink" title="使用Scroller"></a>使用Scroller</h3><p><a href="https://www.jianshu.com/p/cce0d5fc8c35" target="_blank" rel="noopener">https://www.jianshu.com/p/cce0d5fc8c35</a></p><h3 id="通过动画"><a href="#通过动画" class="headerlink" title="通过动画"></a>通过动画</h3><p>在onAnimationnUpdate中加上scrollTo方法进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> deltaX = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">final</span> ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>,<span class="number">1</span>).setDuration(<span class="number">1000</span>);</span><br><span class="line">animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> fraction = animator.getAnimatedFraction();</span><br><span class="line">        mButton.scrollTo(startX + (<span class="keyword">int</span>) (deltaX * fraction), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure><h3 id="使用延时策略"><a href="#使用延时策略" class="headerlink" title="使用延时策略"></a>使用延时策略</h3><p>使用Handler或View的postDelayed方法。</p><h2 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h2><p><a href="https://blog.csdn.net/carson_ho/article/details/54136311" target="_blank" rel="noopener">https://blog.csdn.net/carson_ho/article/details/54136311</a></p><p>这篇博客写得比较清楚。</p><h2 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h2><p>常见滑动冲突场景：</p><ul><li>场景1——外部滑动方向和内部滑动方向不一致</li><li>场景2——外部滑动方向和内部滑动方向一致</li><li>场景3——上面两种情况的嵌套</li></ul><img src="/2019/05/15/Android开发艺术探索笔记系列-第3章-View的事件体系/1557909679329.png"><p><img src="D:\Desktop\学\一\項目\Android开发艺术探索\1557909679329.png" alt=""></p><h3 id="处理规则"><a href="#处理规则" class="headerlink" title="处理规则"></a>处理规则</h3><p>场景1：用户左右滑动时，需要外部的View拦截点击事件，用户上下滑动时，需要让内部View拦截点击事件。一般可以根据水平和竖直方向滑动的距离来判断方向。</p><p>场景2：在业务上找突破点。</p><p>场景3：同上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;View的事件体系&quot;&gt;&lt;a href=&quot;#View的事件体系&quot; class=&quot;headerlink&quot; title=&quot;View的事件体系&quot;&gt;&lt;/a&gt;View的事件体系&lt;/h1&gt;&lt;h2 id=&quot;View基础知识&quot;&gt;&lt;a href=&quot;#View基础知识&quot; class=&quot;headerlink&quot; title=&quot;View基础知识&quot;&gt;&lt;/a&gt;View基础知识&lt;/h2&gt;&lt;h3 id=&quot;什么是View&quot;&gt;&lt;a href=&quot;#什么是View&quot; class=&quot;headerlink&quot; title=&quot;什么是View&quot;&gt;&lt;/a&gt;什么是View&lt;/h3&gt;&lt;p&gt;View是Android中所有控件的基类。&lt;/p&gt;
&lt;p&gt;ViewGroup内部包含了一组View，它也继承自View。这种关系形成了View树的概念。
    
    </summary>
    
      <category term="Android开发艺术探索笔记" scheme="https://wcxdhr.github.io/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索笔记系列-第1章-Activity的生命周期和启动模式</title>
    <link href="https://wcxdhr.github.io/2019/04/24/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC1%E7%AB%A0-Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://wcxdhr.github.io/2019/04/24/Android开发艺术探索笔记系列-第1章-Activity的生命周期和启动模式/</id>
    <published>2019-04-24T08:21:46.000Z</published>
    <updated>2019-05-15T09:00:39.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Activity的生命周期分析"><a href="#Activity的生命周期分析" class="headerlink" title="Activity的生命周期分析"></a>Activity的生命周期分析</h2><img src="/2019/04/24/Android开发艺术探索笔记系列-第1章-Activity的生命周期和启动模式/1555903104817.png"><h3 id="正常情况下的生命周期"><a href="#正常情况下的生命周期" class="headerlink" title="正常情况下的生命周期"></a>正常情况下的生命周期</h3><p>如上图中心线所示。<a id="more"></a></p><p>Activity切换时，旧Activity先onPause，新Activity再启动。</p><p>onPause执行完成后新Activity才能Resume，因此onPause中不能做重量级操作。（onStop中可以做稍微重量级一些的工作，也不能太耗时）</p><h3 id="异常情况下的生命周期"><a href="#异常情况下的生命周期" class="headerlink" title="异常情况下的生命周期"></a>异常情况下的生命周期</h3><p>异常情况指Activity被系统回收或当前设备Configuration发生改变。</p><h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><p><strong>资源相关的系统配置发生改变导致Activity被杀死并重新创建</strong></p><p>例如旋转屏幕</p><img src="/2019/04/24/Android开发艺术探索笔记系列-第1章-Activity的生命周期和启动模式/1555913057138.png"><p>在onStop之前调用onSaveInstanceState来保存Activity状态。（可能在onPause之前，也可能在onPause之后）。</p><p>Activity重新创建后，系统会调用onRestoreInstanceState（在onStart之后），并将onSaveInstanceState保存的Bundle对象作为参数传给onCreate和onRestoreInstanceState。</p><p>系统自动做的恢复工作：当前Activity的视图结构（例如文本框中的输入数据，ListView滚动的位置）。</p><p>保存数据和恢复数据采用的是委托思想。Activity委托Window，Window再委托它上面的顶级容器来保存数据（一般是一个ViewGroup，很可能是DecorView）。顶级容器再一一通知它的子元素来保存数据。</p><p><strong>注：onRestoreInstanceState会对Bundl判空，onCreate不会</strong></p><h4 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h4><p><strong>系统内存不足导致低优先级的Activity被杀死</strong></p><p><strong>注：</strong> 当系统配置发生改变后，若不想系统重新创建Activity，可以给Activity指定configChanges属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//example</span><br><span class="line">android:configChanges="orientation"</span><br></pre></td></tr></table></figure><p>这样屏幕方向改变时，Activity不会被销毁重建，而是系统调用Activity的onConfigurationChanged方法。</p><h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><h3 id="Activity的LaunchMode"><a href="#Activity的LaunchMode" class="headerlink" title="Activity的LaunchMode"></a>Activity的LaunchMode</h3><ul><li><p><strong>standard 标准模式</strong></p><p>默认模式，重复创建。</p></li><li><p><strong>singleTop 栈顶复用模式</strong></p><p>若Activity位于任务栈的栈顶，不会重新创建，而是调用onNewIntent方法。否则会重新创建。</p></li><li><p><strong>singleTask 栈内复用模式</strong></p><p>只要Activity在一个栈中存在，则多次启动不会重新创建实例。注：该模式具有clearTop效果，栈内所有在上面的Activity会全部出栈。</p></li><li><p><strong>singleInstance 单实例模式</strong></p><p>加强版的singleTask，Activity只能单独地位于一个任务栈中。</p></li></ul><p><strong>任务栈：TaskAffinity标识了所需要的任务栈的名字</strong></p><p><strong>给Activity指定启动模式的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line">android:launchMode = <span class="string">"singleTask"</span></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br></pre></td></tr></table></figure><p>方法二的优先级高于方法一，限定范围有所不同。</p><h3 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h3><p>一些常用的标记位：</p><ul><li><p>FLAGS_ACTIVITY_NEW_TASK</p><p>指定singleTask启动模式</p></li><li><p>FLAGS_ACTIVITY_SINGLE_TOP</p><p>指定singleTop启动模式</p></li><li><p>FLAGS_ACTIVITY_CLEAR_TOP</p><p>清除栈内该Activity上面的Activity（出栈）</p></li><li><p>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</p><p>Activity不会出现在历史Activity列表中</p></li></ul><h2 id="IntentFilter的匹配规则"><a href="#IntentFilter的匹配规则" class="headerlink" title="IntentFilter的匹配规则"></a>IntentFilter的匹配规则</h2><p>启动Activity的隐式调用中，需要Intent能够匹配目标组件的IntentFilter中所设置的过滤信息。</p><p>IntentFilter中的过滤信息有action、category、data。</p><p>匹配时需要全部匹配，有多个intent-filter时，能匹配任意一组即可启动。</p><p><strong>action</strong></p><p>要求Intent中action存在且必须至少有一个和过滤规则中的其中一个action相同，区分大小写。</p><p><strong>category</strong></p><p>Intent中可以没有category（这时category默认为“android.intent.category.DEFAULT“，只要intent-filter中有相应category即可接收隐式调用）。</p><p>一旦有category每一个都要与过滤规则中的其中一个category相同。</p><p><strong>data</strong></p><p>与action类似。</p><p>Data属性通常用来向Action属性提供操作的数据。</p><p><strong>注：Service建议尽量使用显式调用</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Activity的生命周期分析&quot;&gt;&lt;a href=&quot;#Activity的生命周期分析&quot; class=&quot;headerlink&quot; title=&quot;Activity的生命周期分析&quot;&gt;&lt;/a&gt;Activity的生命周期分析&lt;/h2&gt;&lt;img src=&quot;/2019/04/24/Android开发艺术探索笔记系列-第1章-Activity的生命周期和启动模式/1555903104817.png&quot;&gt;
&lt;h3 id=&quot;正常情况下的生命周期&quot;&gt;&lt;a href=&quot;#正常情况下的生命周期&quot; class=&quot;headerlink&quot; title=&quot;正常情况下的生命周期&quot;&gt;&lt;/a&gt;正常情况下的生命周期&lt;/h3&gt;&lt;p&gt;如上图中心线所示。
    
    </summary>
    
      <category term="Android开发艺术探索笔记" scheme="https://wcxdhr.github.io/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java读书笔记系列 第8章 泛型程序设计</title>
    <link href="https://wcxdhr.github.io/2019/03/15/Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC8%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://wcxdhr.github.io/2019/03/15/Java读书笔记系列-第8章-泛型程序设计/</id>
    <published>2019-03-15T02:21:40.000Z</published>
    <updated>2019-05-15T09:02:30.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第8章-泛型程序设计"><a href="#第8章-泛型程序设计" class="headerlink" title="第8章 泛型程序设计"></a>第8章 泛型程序设计</h1><p>泛型对于集合类尤其有用，ArrayList就是一个无处不在的类。<a id="more"></a></p><h2 id="8-2-定义简单泛型类"><a href="#8-2-定义简单泛型类" class="headerlink" title="8.2 定义简单泛型类"></a>8.2 定义简单泛型类</h2><p>一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;//<span class="title">T</span>是类型变量</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：JAVA库中一般使用E表示集合的元素类型，K和V分别表示表的关键字与值的类型。T（有时也可以用临近的U和S）表示”任意类型“</strong></p><h2 id="8-3-泛型方法"><a href="#8-3-泛型方法" class="headerlink" title="8.3 泛型方法"></a>8.3 泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用该方法</span></span><br><span class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"dddd"</span>,<span class="string">"aaaa"</span>);<span class="comment">//&lt;String&gt;可以省略</span></span><br></pre></td></tr></table></figure><h2 id="8-4-类型变量的限定"><a href="#8-4-类型变量的限定" class="headerlink" title="8.4 类型变量的限定"></a>8.4 类型变量的限定</h2><p>有时，类或方法需要对类型变量加以约束。例如将T限制为实现了Comparable接口的类，可恶意通过对类型变量T设置限定实现这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span>...</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends BoundingType&gt;<span class="comment">//表示T是绑定类型的子类型，既可以是接口也可以是类</span></span><br></pre></td></tr></table></figure><p>一个类型变量或通配符可以有多个限定，中间用&amp;分隔。</p><h2 id="8-5-泛型代码和虚拟机"><a href="#8-5-泛型代码和虚拟机" class="headerlink" title="8.5 泛型代码和虚拟机"></a>8.5 泛型代码和虚拟机</h2><blockquote><p><a href="https://blog.csdn.net/briblue/article/details/76736356" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/76736356</a>  这篇博客讲的类型擦除更容易理解。</p></blockquote><h3 id="8-5-3-翻译泛型方法"><a href="#8-5-3-翻译泛型方法" class="headerlink" title="8.5.3 翻译泛型方法"></a>8.5.3 翻译泛型方法</h3><p>有关Java泛型转换的事实：</p><ul><li>虚拟机中没有泛型，只有普通的类和方法。</li><li>所有的类型参数都用它们的限定类型替换。</li><li>桥方法被合成来保持多态。</li><li>为保持类型安全性，必要时插入强制类型转换。</li></ul><h3 id="8-5-4-调用遗留代码"><a href="#8-5-4-调用遗留代码" class="headerlink" title="8.5.4 调用遗留代码"></a>8.5.4 调用遗留代码</h3><p>注解（annotation）可以使警告消失：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注解放在生成警告的代码所在的方法前。</p><h2 id="8-6-约束与局限性"><a href="#8-6-约束与局限性" class="headerlink" title="8.6 约束与局限性"></a>8.6 约束与局限性</h2><p>以下大多数限制都是由类型擦除引起的。</p><h3 id="8-6-1-不能用基本类型实例化类型参数"><a href="#8-6-1-不能用基本类型实例化类型参数" class="headerlink" title="8.6.1 不能用基本类型实例化类型参数"></a>8.6.1 不能用基本类型实例化类型参数</h3><p>没有Pair&lt;double&gt;，只有Pair&lt;Double&gt;，原因是类型擦除。擦除后Pair类含有Object类型的域，而Object不能存储double值。</p><h3 id="8-6-2-运行时类型查询只适用于原始类型"><a href="#8-6-2-运行时类型查询只适用于原始类型" class="headerlink" title="8.6.2 运行时类型查询只适用于原始类型"></a>8.6.2 运行时类型查询只适用于原始类型</h3><p>虚拟机中的对象总有一个特定的非泛型类型。因此，所有类型查询只产生原始类型。</p><p>getClass方法也总是 返回原始类型。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair = ...;</span><br><span class="line">Pair&lt;Employee&gt; employeePair = ...;</span><br><span class="line"><span class="keyword">if</span>(stringPair.geetClass() == employeePair.getClass())<span class="comment">//相等，两次调用都返回Pair.class</span></span><br></pre></td></tr></table></figure><h3 id="8-6-3-不能创建参数化类型的数组"><a href="#8-6-3-不能创建参数化类型的数组" class="headerlink" title="8.6.3 不能创建参数化类型的数组"></a>8.6.3 不能创建参数化类型的数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//Error</span></span><br></pre></td></tr></table></figure><h3 id="8-6-4-Varargs-警告"><a href="#8-6-4-Varargs-警告" class="headerlink" title="8.6.4 Varargs 警告"></a>8.6.4 Varargs 警告</h3><p>向参数个数可变的方法传递一个泛型类型的实例。</p><p>考虑下面方法，参数个数是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; coll, T... ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (t : ts) coll.add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑以下调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Pair&lt;String&gt;&gt; table = ...;</span><br><span class="line">Pair&lt;String&gt; pair1 = ...;</span><br><span class="line">Pair&lt;String&gt; pair2 = ...;</span><br><span class="line">addAll(table, pair1, pair2);</span><br></pre></td></tr></table></figure><p>为了调用这个方法，Java虚拟机必须建立一个Pair&lt;String&gt;数组，这就违反了前面的规则。不过，在这种情况下，规则有所放松，只会得到一个警告，而不是错误。</p><p>有两种方法来抑制这个警告。</p><ul><li>为包含addAll调用的方法增加注解@SuppressWarnings(“unchecked”)</li><li>在Java SE 7中，还可以用@SafeVarargs直接标注addAll方法</li></ul><h3 id="8-6-5-不能实例化类型变量"><a href="#8-6-5-不能实例化类型变量" class="headerlink" title="8.6.5 不能实例化类型变量"></a>8.6.5 不能实例化类型变量</h3><p>不能使用像new T(…)，new T[…]或T.class这样的表达式中的类型变量。</p><p>类型擦除会将T改变为Object（本意不会想调用new Object() )</p><p>在Java SE 8之后，最好的解决方法是让调用者提供一个构造器表达式。</p><p>以下省略。</p><h3 id="8-6-6-不能构造泛型数组"><a href="#8-6-6-不能构造泛型数组" class="headerlink" title="8.6.6 不能构造泛型数组"></a>8.6.6 不能构造泛型数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T[] a) &#123;T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>];...&#125;<span class="comment">//Error</span></span><br></pre></td></tr></table></figure><p>类型擦除会让这个方法永远构造Comparable[2]数组。</p><h3 id="8-6-7-泛型类的静态上下文中类型变量无效"><a href="#8-6-7-泛型类的静态上下文中类型变量无效" class="headerlink" title="8.6.7 泛型类的静态上下文中类型变量无效"></a>8.6.7 泛型类的静态上下文中类型变量无效</h3><p>不能在静态域或方法中引用类型变量。</p><p>原因：类型擦除。</p><h3 id="8-6-8-不能抛出或捕获泛型类的实例"><a href="#8-6-8-不能抛出或捕获泛型类的实例" class="headerlink" title="8.6.8 不能抛出或捕获泛型类的实例"></a>8.6.8 不能抛出或捕获泛型类的实例</h3><p>###8.6.9 可以消除对受查异常的检查 </p><p>Java异常处理的一个基本原则是必须为所有受查异常提供一个处理器。可以利用泛型消除这个限制。</p><p>具体不做介绍。总之，通过使用泛型类、擦除和@SuppressWarnings注解，就能消除Java类型系统的部分基本限制。</p><h3 id="8-6-10-注意擦除后的限制"><a href="#8-6-10-注意擦除后的限制" class="headerlink" title="8.6.10 注意擦除后的限制"></a>8.6.10 注意擦除后的限制</h3><p>当泛型类型被擦除时，无法创建引发冲突的条件。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span> </span>&#123;<span class="keyword">return</span> first.equals(value) &amp;&amp; second.equals(value)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑Pair&lt;String&gt;。从概念上讲，它有两个equals方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String)</span><span class="comment">//来自Pair&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span><span class="comment">//继承自Object</span></span></span><br></pre></td></tr></table></figure><p>方法擦除使两个方法发生冲突。补救方法是重新命名引发错误的方法。</p><p>泛型规范说明还提到另外一个原则：”要想支持擦除的转换，就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一个接口的不同参数化。“</p><h2 id="8-7-泛型类型的继承规则"><a href="#8-7-泛型类型的继承规则" class="headerlink" title="8.7 泛型类型的继承规则"></a>8.7 泛型类型的继承规则</h2><img src="/2019/03/15/Java读书笔记系列-第8章-泛型程序设计/1552637440813.png"><p>如图所示，无论S与T有什么关系，一般Pair&lt;S&gt;和Pair&lt;T&gt;没有任何关系。</p><p>泛型类可以扩展或实现其他的泛型类。</p><img src="/2019/03/15/Java读书笔记系列-第8章-泛型程序设计/1552638021809.png"><h2 id="8-8-通配符类型"><a href="#8-8-通配符类型" class="headerlink" title="8.8 通配符类型"></a>8.8 通配符类型</h2><h3 id="8-8-1-通配符概念"><a href="#8-8-1-通配符概念" class="headerlink" title="8.8.1 通配符概念"></a>8.8.1 通配符概念</h3><p>通配符类型中，允许类型参数变化。例如，通配符类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;? extends Employee&gt;</span><br></pre></td></tr></table></figure><p>表示任何泛型Pair类型，它的类型参数是Employee的子类。</p><img src="/2019/03/15/Java读书笔记系列-第8章-泛型程序设计/1552638625510.png"><p>Pair&lt;Manager&gt;是Pair&lt;? extends Employee&gt;的子类型。</p><p>可以为方法使用返回值，但不能提供参数。</p><h3 id="8-8-2-通配符的超类型限定"><a href="#8-8-2-通配符的超类型限定" class="headerlink" title="8.8.2 通配符的超类型限定"></a>8.8.2 通配符的超类型限定</h3><p>通配符限定可以指定一个类型限定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? <span class="keyword">super</span> Manager</span><br></pre></td></tr></table></figure><p>这个通配符限制为所有Manager的超类型。</p><img src="/2019/03/15/Java读书笔记系列-第8章-泛型程序设计/1552639688776.png"><p>可以为方法提供参数，但不能使用返回值。</p><p>直观地讲，<strong>带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。</strong></p><h3 id="8-8-3-无限定通配符"><a href="#8-8-3-无限定通配符" class="headerlink" title="8.8.3 无限定通配符"></a>8.8.3 无限定通配符</h3><p>可以使用无限定的通配符，它与原始的Pair类型有很大不同。</p><p>Pair&lt;?&gt;有以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? getFirst()<span class="comment">//返回值只能赋给一个Object。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(?)</span><span class="comment">//该方法不能被调用（也不能用Object调用</span></span></span><br></pre></td></tr></table></figure><p><strong>注：可以调用setFirst(null)</strong></p><p>为什么要使用这样脆弱的类型呢？它对于许多简单的操作非常有用。例如下面这个方法将用来测试一个pair是否包含null引用，它不需要实际的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.getFirst == <span class="keyword">null</span> || p.getSecond == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-9-反射和泛型"><a href="#8-9-反射和泛型" class="headerlink" title="8.9 反射和泛型"></a>8.9 反射和泛型</h2><blockquote><p><a href="https://juejin.im/post/5abb78b56fb9a028e25d9c32" target="_blank" rel="noopener">https://juejin.im/post/5abb78b56fb9a028e25d9c32</a> 通俗易懂一些。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第8章-泛型程序设计&quot;&gt;&lt;a href=&quot;#第8章-泛型程序设计&quot; class=&quot;headerlink&quot; title=&quot;第8章 泛型程序设计&quot;&gt;&lt;/a&gt;第8章 泛型程序设计&lt;/h1&gt;&lt;p&gt;泛型对于集合类尤其有用，ArrayList就是一个无处不在的类。
    
    </summary>
    
      <category term="Java核心技术卷Ⅰ读书笔记" scheme="https://wcxdhr.github.io/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java读书笔记系列 第7章 异常、断言和日志</title>
    <link href="https://wcxdhr.github.io/2019/03/13/Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC7%E7%AB%A0-%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/"/>
    <id>https://wcxdhr.github.io/2019/03/13/Java读书笔记系列-第7章-异常、断言和日志/</id>
    <published>2019-03-13T12:44:25.000Z</published>
    <updated>2019-05-15T09:10:25.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第7章-异常、断言和日志"><a href="#第7章-异常、断言和日志" class="headerlink" title="第7章 异常、断言和日志"></a>第7章 异常、断言和日志</h1><h2 id="7-1-处理错误"><a href="#7-1-处理错误" class="headerlink" title="7.1 处理错误"></a>7.1 处理错误</h2><h3 id="7-1-1-异常分类"><a href="#7-1-1-异常分类" class="headerlink" title="7.1.1 异常分类"></a>7.1.1 异常分类</h3><img src="/2019/03/13/Java读书笔记系列-第7章-异常、断言和日志/1552293327061.png"><ul><li>Error类：Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出。<a id="more"></a></li><li>Exception类：</li><li><ul><li>RuntimeException：由于程序错误导致的异常。有以下情况</li><li><ul><li>错误的类型转换。</li><li>数组访问越界。</li><li>访问null指针。</li></ul></li><li>IOException：程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。</li><li><ul><li>试图在文件尾部后面读取数据。</li><li>试图打开一个不存在的文件。</li><li>试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。</li></ul></li></ul></li></ul><p><strong>“如果出现RuntimeException异常，那一定就是你的问题”</strong>是一条相当有道理的规则。</p><p>Java语言规范将派生于Error类或RuntimeException类的所有异常称为<strong>非受查异常</strong>，所有其他的异常称为<strong>受查异常</strong>。编译器将核查是否为所有的受查异常提供了异常处理器。</p><h3 id="7-1-2-声明受查异常"><a href="#7-1-2-声明受查异常" class="headerlink" title="7.1.2 声明受查异常"></a>7.1.2 声明受查异常</h3><p>如果遇到了无法处理的情况，那么Java的方法可以抛出一个异常。一个方法不仅需要告诉编译器将要返回什么值，<strong>还要告诉编译器有可能发生什么错误</strong>。</p><p>方法应该在其首部声明所有可能抛出的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br></pre></td></tr></table></figure><p>在下面4种情况下应该抛出异常：</p><ul><li>调用一个抛出受查异常的方法，例如，FileInputStream构造器。</li><li>程序运行过程中发现错误，并且利用throw语句抛出一个受查异常。</li><li>程序出现错误，例如，a[-1]=0会抛出一个ArrayIndexOutBoundsException这样的非受查异常。</li><li>Java虚拟机和运行库出现的内部错误。</li></ul><h3 id="7-1-3-如何抛出异常"><a href="#7-1-3-如何抛出异常" class="headerlink" title="7.1.3 如何抛出异常"></a>7.1.3 如何抛出异常</h3><p>对于一个已经存在的类，将其抛出步骤如下：</p><ul><li>找到一个合适的异常类</li><li>创建这个类的一个对象</li><li>将对象抛出</li></ul><h2 id="7-2-捕获异常"><a href="#7-2-捕获异常" class="headerlink" title="7.2 捕获异常"></a>7.2 捕获异常</h2><h3 id="7-2-1-捕获异常"><a href="#7-2-1-捕获异常" class="headerlink" title="7.2.1 捕获异常"></a>7.2.1 捕获异常</h3><p>要想捕获异常，必须设置try/catch语句块，如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，那么：</p><ul><li>程序将跳过try语句块的其余代码。</li><li>程序将执行catch子句中的处理器代买。</li></ul><p>传递异常：在方法声明后throws IOException。</p><p><strong>应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递。</strong></p><h3 id="7-2-4-finally子句"><a href="#7-2-4-finally子句" class="headerlink" title="7.2.4 finally子句"></a>7.2.4 finally子句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(...);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure><p>以上代码，在3种情况下会执行finally子句：</p><ul><li><p>代码没有抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>-<span class="keyword">finally</span><span class="comment">//执行1-2-5-6</span></span><br></pre></td></tr></table></figure></li><li><p>抛出一个在catch子句中捕获的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>-<span class="keyword">catch</span>-<span class="keyword">finally</span><span class="comment">//执行1-3-4-5-6</span></span><br><span class="line"><span class="comment">//若catch子句抛出异常，异常会被抛回这个方法的调用者，执行1-3-5</span></span><br></pre></td></tr></table></figure></li><li><p>代码抛出一个异常但这个异常不是由catch子句捕获的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>-<span class="keyword">finally</span><span class="comment">//执行1-5</span></span><br></pre></td></tr></table></figure></li></ul><p>try语句可以只有finally子句，没有catch子句。</p><h3 id="7-2-5-带资源的try语句"><a href="#7-2-5-带资源的try语句" class="headerlink" title="7.2.5 带资源的try语句"></a>7.2.5 带资源的try语句</h3><p>带资源的try语句最简形式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Resource res = ...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try块退出时，会自动调用res.close()。</p><h2 id="7-3-使用异常机制的技巧"><a href="#7-3-使用异常机制的技巧" class="headerlink" title="7.3 使用异常机制的技巧"></a>7.3 使用异常机制的技巧</h2><ul><li><p>异常处理不能代替简单的测试</p><p>与执行简单的测试相比，捕获异常所花费的世间大大超过了前者，使用异常的基本规则是：只在异常情况下使用异常机制。</p></li><li><p>不要过分细化异常</p></li><li><p>利用异常层次结构</p><p>不要只抛出RuntimeException异常。应该寻找更加适当的子类或创建自己的异常类。</p><p>不要只捕获Thowable异常，否则会使代码更难读、更难维护。‘</p><p>考虑受查异常和非受查异常的区别。已检查异常本来就很庞大，不要为逻辑错误抛出这些异常。</p></li><li><p>不要压制异常</p><p>书上这里看不懂，不知道在讲什么。</p><p>网上查阅结果：</p><p>不要在catch子句中压制异常（例如在子句中return null），如果不知道如何处理异常，最好将异常重新抛出，由上层决定如何处理异常。</p></li><li><p>在检测错误时，“苛刻”要比放任更好</p></li><li><p>不要羞于传递异常</p></li></ul><p>注：最后两条归纳为<strong>早抛出，晚捕获“</strong></p><h2 id="7-4-使用断言"><a href="#7-4-使用断言" class="headerlink" title="7.4 使用断言"></a>7.4 使用断言</h2><p>在一个具有自我保护能力的程序中，断言很常用。</p><p>断言机制允许在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句会被自动移走。</p><p>Java语言引入了关键字assert。这个关键字有两种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> 条件;</span><br><span class="line"><span class="keyword">assert</span> 条件 : 表达式;</span><br></pre></td></tr></table></figure><p>如果结果为false，则抛出一个AssertionError异常。第二种形式中，表达式将被传入AssertionError的构造器，并转换成一个消息字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码断言x是一个非负数值</span></span><br><span class="line"><span class="keyword">assert</span> x =&gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">//或传给AssertionError</span></span><br><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : x;</span><br></pre></td></tr></table></figure><h3 id="7-4-2-启用和禁用断言"><a href="#7-4-2-启用和禁用断言" class="headerlink" title="7.4.2 启用和禁用断言"></a>7.4.2 启用和禁用断言</h3><p>在默认情况下，断言被禁用。可以在运行程序时用-enableassertions或-ea选项启用。</p><h3 id="7-4-3-使用断言完成参数检查"><a href="#7-4-3-使用断言完成参数检查" class="headerlink" title="7.4.3 使用断言完成参数检查"></a>7.4.3 使用断言完成参数检查</h3><p>在Java语言中，给出了3种处理系统错误的机制：</p><ul><li>抛出一个异常</li><li>日志</li><li>使用断言</li></ul><p>使用断言要注意以下几点：</p><ul><li>断言失败是致命的、不可恢复的错误。</li><li>断言检查只用于开发和测阶段。</li></ul><h2 id="7-5-记录日志"><a href="#7-5-记录日志" class="headerlink" title="7.5 记录日志"></a>7.5 记录日志</h2><p>记录日志API的优点：</p><ul><li>可以很容易地取消全部日志记录，或者仅仅取消某个级别的日志，而且打开和关闭这个操作也很容易。</li><li>可以很简单地禁止日志记录地输出，因此，将这些日志代码留在程序中开销很小。</li><li>日志记录可以被定向到不同的处理器，用于在控制台显示，用于存储在文件中等。</li><li>日志记录器和处理器都可以对日志进行过滤。过滤器可以根据过滤实现器制定的标准丢弃那些无用地记录项。</li><li>日志记录可以采用不同的方法格式化，例如，纯文本或XML。</li><li>应用程序可以使用多个日志记录器，它们使用类似包名地这种具有层次结构的名字。</li><li>在默认情况下，日志系统的配置由配置文件控制。如果需要的话，应用程序可以替换这个配置。</li></ul><h3 id="7-5-2-高级日志"><a href="#7-5-2-高级日志" class="headerlink" title="7.5.2 高级日志"></a>7.5.2 高级日志</h3><p>调用getLogger方法创建或获取记录器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger myLogger = Logger.getLogger(<span class="string">"com.mycompany.myapp"</span>);</span><br></pre></td></tr></table></figure><p>日志记录器有7个级别：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.setLevel(Level.FINE);<span class="comment">//FINE和更高级别的记录都可以记录下来。</span></span><br></pre></td></tr></table></figure><h3 id="7-5-8-日志记录说明"><a href="#7-5-8-日志记录说明" class="headerlink" title="7.5.8 日志记录说明"></a>7.5.8 日志记录说明</h3><p>以下是一些最常用的操作：</p><ul><li>为一个简单的应用程序，选择一个日志记录器，并把日志记录器命名为与主应用程序包一样的名字，这是一种好的编程习惯。</li><li>默认的日志配置将级别等于或高于INFO级别的所有消息记录到控制台。用户可以覆盖默认的配置文件。但改变需要做相当多的工作，因此，最好在应用程序中安装一个更加适宜的默认配置。</li><li>由于等于或高于INFO级别的消息都显示在控制台上，最好只将对程序用户有意义的消息设置为这几个级别，将程序员想要的日志记录设定为FINE是一个很好的选择。</li></ul><h2 id="7-6-调试技巧"><a href="#7-6-调试技巧" class="headerlink" title="7.6 调试技巧"></a>7.6 调试技巧</h2><ul><li><p>可以用下面的方法打印或记录任意变量的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"x="</span> + x);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">Logger.getGlobal().info(<span class="string">"x="</span> + x);</span><br></pre></td></tr></table></figure><p>若x是一个数值，则会被转换成等价的字符串。若x是一个对象，则Java会调用这个对象的toString方法。</p></li><li><p>一个有效技巧是在每一个类中放置一个单独的main方法，用以对每个类进行单元测试。</p></li><li><p>JUnit是一个非常常见的单元测试框架。</p></li><li><p>日志代理是一个子类的对象，它可以截获方法调用，并进行日志记录，然后调用超类中的方法。</p></li><li><p>利用Throwable类提供的printStackTrace方法，可以从任何一个异常对象中获得堆栈情况。</p></li><li><p>一般来说，堆栈轨迹显示在System.err上。也可以利用printStackTrace(PrintWriter s)方法将它发送到一个文件中。</p></li></ul><p>后续省略。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第7章-异常、断言和日志&quot;&gt;&lt;a href=&quot;#第7章-异常、断言和日志&quot; class=&quot;headerlink&quot; title=&quot;第7章 异常、断言和日志&quot;&gt;&lt;/a&gt;第7章 异常、断言和日志&lt;/h1&gt;&lt;h2 id=&quot;7-1-处理错误&quot;&gt;&lt;a href=&quot;#7-1-处理错误&quot; class=&quot;headerlink&quot; title=&quot;7.1 处理错误&quot;&gt;&lt;/a&gt;7.1 处理错误&lt;/h2&gt;&lt;h3 id=&quot;7-1-1-异常分类&quot;&gt;&lt;a href=&quot;#7-1-1-异常分类&quot; class=&quot;headerlink&quot; title=&quot;7.1.1 异常分类&quot;&gt;&lt;/a&gt;7.1.1 异常分类&lt;/h3&gt;&lt;img src=&quot;/2019/03/13/Java读书笔记系列-第7章-异常、断言和日志/1552293327061.png&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Error类：Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出。
    
    </summary>
    
      <category term="Java核心技术卷Ⅰ读书笔记" scheme="https://wcxdhr.github.io/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java读书笔记系列 第6章 接口、lambda表达式与内部类</title>
    <link href="https://wcxdhr.github.io/2019/03/13/Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC6%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://wcxdhr.github.io/2019/03/13/Java读书笔记系列-第6章-接口、lambda表达式与内部类/</id>
    <published>2019-03-13T12:44:02.000Z</published>
    <updated>2019-03-13T15:50:48.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第6章-接口、lambda表达式与内部类"><a href="#第6章-接口、lambda表达式与内部类" class="headerlink" title="第6章 接口、lambda表达式与内部类"></a>第6章 接口、lambda表达式与内部类</h1><h2 id="6-1-接口"><a href="#6-1-接口" class="headerlink" title="6.1 接口"></a>6.1 接口</h2><p>接口技术用来描述类具有什么功能，并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要的地方，随时使用实现了相应接口的的对象。<a id="more"></a></p><p>接口中的所有方法自动地属于public。因此，在接口中声明方法时，不必提供关键字public。<strong>在实现接口时，必须把方法声明为public</strong> </p><p>接口绝不能含有实例域——接口没有实例。但接口中可以包含常量（public static final constant)。接口可以被扩展。</p><p>提供实例域和方法实现的任务应该由实现接口的那个类来完成。可以将接口看成没有实例域的抽象类。</p><p>为了让类实现一个接口，通常需要下面两个步骤：</p><ul><li>将类声明为实现给定的接口</li><li>对接口中的所有方法进行定义</li></ul><h3 id="6-1-3-接口与抽象类"><a href="#6-1-3-接口与抽象类" class="headerlink" title="6.1.3 接口与抽象类"></a>6.1.3 接口与抽象类</h3><p>每个类只能继承一个类（C++的多重继承会让语言本身变得非常复杂），但每个类可以实现多个接口。</p><p>接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p><h3 id="6-1-6-默认方法冲突"><a href="#6-1-6-默认方法冲突" class="headerlink" title="6.1.6 默认方法冲突"></a>6.1.6 默认方法冲突</h3><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，规则如下：</p><ul><li>超类优先。如果超类提供了一个具体方法，同名而且有相同的参数类型的默认方法会被忽略。</li><li>接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否默认参数）相同的方法，必须覆盖这个方法来解决冲突。</li></ul><h2 id="6-3-lambda（λ）表达式"><a href="#6-3-lambda（λ）表达式" class="headerlink" title="6.3 lambda（λ）表达式"></a>6.3 lambda（λ）表达式</h2><h3 id="6-3-2-lambda表达式语法"><a href="#6-3-2-lambda表达式语法" class="headerlink" title="6.3.2 lambda表达式语法"></a>6.3.2 lambda表达式语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second)</span><br><span class="line">-&gt; first.lengthh() - second.length()</span><br></pre></td></tr></table></figure><p>以上是一种lambda表达式形式：参数，箭头（-&gt;)以及一个表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，可将表达式变为方法，放在一个代码块中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><p>没有参数时，仍然要提供空括号。</p><p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型；如果方法只有一个参数，而且这个参数类型可以推导得出，则还可以省略()。</p><p>无需指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出。</p><h3 id="6-3-3-函数式接口"><a href="#6-3-3-函数式接口" class="headerlink" title="6.3.3 函数式接口"></a>6.3.3 函数式接口</h3><p>对于只有一个抽象方法的接口，当需要这种接口的对象时，就可以提供lambda表达式。这种接口称为函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words,</span><br><span class="line">           (first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure><p>Arrays.sort的第二个参数需要一个Comparator实例，在这里提供一个lambda表达式。</p><p>在底层，Arrays.sort方法会接收实现了Comparator<string>的某个类的对象。在这个对象上调用compare方法会执行这个lambda表达式的体。</string></p><p>在Java中，lambda表达式只能转换为函数式接口。</p><h3 id="6-3-4-方法引用"><a href="#6-3-4-方法引用" class="headerlink" title="6.3.4 方法引用"></a>6.3.4 方法引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, event -&gt; System.out.println(event));</span><br><span class="line"><span class="comment">//出现一个定时器事件就打印这个事件对象</span></span><br><span class="line">Timer t = newTimer(<span class="number">1000</span>, System.out::println);</span><br><span class="line"><span class="comment">//System.out::println为一个方法引用，等价于x -&gt; System.out.println(x)</span></span><br></pre></td></tr></table></figure><p><em>注：第四节内部类后未看</em> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第6章-接口、lambda表达式与内部类&quot;&gt;&lt;a href=&quot;#第6章-接口、lambda表达式与内部类&quot; class=&quot;headerlink&quot; title=&quot;第6章 接口、lambda表达式与内部类&quot;&gt;&lt;/a&gt;第6章 接口、lambda表达式与内部类&lt;/h1&gt;&lt;h2 id=&quot;6-1-接口&quot;&gt;&lt;a href=&quot;#6-1-接口&quot; class=&quot;headerlink&quot; title=&quot;6.1 接口&quot;&gt;&lt;/a&gt;6.1 接口&lt;/h2&gt;&lt;p&gt;接口技术用来描述类具有什么功能，并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要的地方，随时使用实现了相应接口的的对象。
    
    </summary>
    
      <category term="Java核心技术卷Ⅰ读书笔记" scheme="https://wcxdhr.github.io/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java读书笔记系列 第5章 继承</title>
    <link href="https://wcxdhr.github.io/2019/03/13/Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF/"/>
    <id>https://wcxdhr.github.io/2019/03/13/Java读书笔记系列-第5章-继承/</id>
    <published>2019-03-13T12:43:34.000Z</published>
    <updated>2019-03-13T15:50:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第5章-继承"><a href="#第5章-继承" class="headerlink" title="第5章 继承"></a>第5章 继承</h1><h2 id="5-1-类、超类和子类"><a href="#5-1-类、超类和子类" class="headerlink" title="5.1 类、超类和子类"></a>5.1 类、超类和子类</h2><p>通过扩展超类定义子类时，只需指出子类与超类的不同之处。</p><p>使用关键字super调用超类。<a id="more"></a></p><p>一个对象变量可以指示多种实际类型的现象被称为<strong>多态</strong>。</p><p>在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定</strong>。</p><p><strong>动态绑定的重要特性</strong>：无需对现存的代码进行修改，就可以对程序进行扩展。不需要重新编译。</p><h3 id="5-1-7-阻止继承：final类和方法"><a href="#5-1-7-阻止继承：final类和方法" class="headerlink" title="5.1.7 阻止继承：final类和方法"></a>5.1.7 阻止继承：final类和方法</h3><p>final类不允许被扩展，final方法不能被覆盖。</p><h3 id="5-1-8-强制类型转换"><a href="#5-1-8-强制类型转换" class="headerlink" title="5.1.8 强制类型转换"></a>5.1.8 强制类型转换</h3><p>将超类的引用赋给一个子类变量，必须进行类型转换。</p><ul><li>只能在继承层次内进行类型转换。</li><li>在将超类转换为子类之前，应该使用instanceof进行检查。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (staff[<span class="number">1</span>] <span class="keyword">instanceof</span> Manager) &#123;</span><br><span class="line">    boss = (Manager) staff[<span class="number">1</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//instanceof:通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例</span></span><br></pre></td></tr></table></figure><p>在一般情况下，应该减少使用类型转换和instanceof运算符。</p><h3 id="5-1-9-抽象类"><a href="#5-1-9-抽象类" class="headerlink" title="5.1.9 抽象类"></a>5.1.9 抽象类</h3><p>包含一个或多个抽象方法的类必须被声明为抽象的。</p><p>抽象类可以不含有抽象方法。</p><h3 id="5-1-10-受保护访问"><a href="#5-1-10-受保护访问" class="headerlink" title="5.1.10 受保护访问"></a>5.1.10 受保护访问</h3><p>Java用于控制可见性的4个访问修饰符：</p><ul><li>仅对本类可见-private</li><li>对所有类可见-public</li><li>对本包和所有子类可见-protected</li><li>对本包可见-默认，不需要修饰符</li></ul><h2 id="5-2-Object：所有类的超类"><a href="#5-2-Object：所有类的超类" class="headerlink" title="5.2 Object：所有类的超类"></a>5.2 Object：所有类的超类</h2><h3 id="5-2-4-toString方法"><a href="#5-2-4-toString方法" class="headerlink" title="5.2.4 toString方法"></a>5.2.4 toString方法</h3><p>toString方法用于返回表示对象值的字符串。</p><p>只要对象与一个字符串通过操作符“+”连接起来，Java编译会自动调用toString方法，以获得该对象的字符串描述。</p><p>toString方法是一种非常有用的调试工具。</p><h2 id="5-3-泛型数组列表"><a href="#5-3-泛型数组列表" class="headerlink" title="5.3 泛型数组列表"></a>5.3 泛型数组列表</h2><p>ArrayList是一个采用类型参数的泛型类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//声明和构造一个保存Employee对象的数组列表</span></span><br></pre></td></tr></table></figure><h2 id="5-6-枚举类"><a href="#5-6-枚举类" class="headerlink" title="5.6 枚举类"></a>5.6 枚举类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size &#123; SMALL, MEDIUM, LARGE, EXTRA_LARGE &#125;;</span><br></pre></td></tr></table></figure><p>这个声明定义的类型是一个类，它有四个实例。</p><h2 id="5-7-反射"><a href="#5-7-反射" class="headerlink" title="5.7 反射"></a>5.7 反射</h2><p>能够分析类能力的程序称为<strong>反射</strong>。</p><p>反射机制用来：</p><ul><li>在运行时分析类的能力</li><li>在运行时查看对象，例如，编写一个toString方法供所有类使用。</li><li>实现通用的数组操作代码</li><li>利用Method对象，这个对象很像C++中的函数指针</li></ul><h3 id="5-7-1-Class类"><a href="#5-7-1-Class类" class="headerlink" title="5.7.1 Class类"></a>5.7.1 Class类</h3><p>程序运行时，Java运行时系统为所有对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。</p><p>保存这些信息的类为Class， Object类中的getClass()将返回一个Class类型的实例。</p><p>获得Class类对象的三种方法：</p><ul><li><p>Object类的getClass()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">Class cl = e.getClass();</span><br></pre></td></tr></table></figure></li><li><p>静态方法forName获得类名对应的Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">"java.util.Random"</span>;</span><br><span class="line">Class cl = Class.forName(className);<span class="comment">//要求className是类名或接口名</span></span><br></pre></td></tr></table></figure></li><li><p>T.class(T为任意的Java类型)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cl1 = <span class="keyword">int</span>.class;</span><br><span class="line">Class cl2 = Double[].class;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-7-2-捕获异常"><a href="#5-7-2-捕获异常" class="headerlink" title="5.7.2 捕获异常"></a>5.7.2 捕获异常</h3><p>异常有两种类型：未检查异常和已检查异常。</p><p>未检查异常尽量避免。</p><p>对于已检查异常，编译器会检查是否提供了处理器。将可能抛出已检查异常的方法调用代码放在try块中，然后在catch子句中提供处理器代码。</p><h3 id="5-7-3-利用反射分析类的能力"><a href="#5-7-3-利用反射分析类的能力" class="headerlink" title="5.7.3 利用反射分析类的能力"></a>5.7.3 利用反射分析类的能力</h3><p>java.lang.reflection中有这三个类：</p><ul><li>Field 描述类的域</li><li>Method 描述类的方法</li><li>Constructor 描述类的构造器</li></ul><p>这三个类通用：</p><ul><li>getName方法，返回项目名称</li><li>getModifiers方法，返回整数值，用不同的位开关描述public和static这样的修饰符使用情况。</li></ul><h3 id="5-7-6-调用任意方法"><a href="#5-7-6-调用任意方法" class="headerlink" title="5.7.6 调用任意方法"></a>5.7.6 调用任意方法</h3><p>Method类的invoke方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br></pre></td></tr></table></figure><p>第一个参数是隐式参数，其余对象提供显式参数，对于静态方法，第一个参数可以被忽略，设置为null。</p><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String n = (String) m1.invoke(harry);</span><br><span class="line"><span class="comment">//m1表示Employee类的getName方法，这条语句调用该方法</span></span><br></pre></td></tr></table></figure><p>使用反射获得方法指针比仅仅直接调用方法更慢。</p><h2 id="5-8-继承设计技巧"><a href="#5-8-继承设计技巧" class="headerlink" title="5.8 继承设计技巧"></a>5.8 继承设计技巧</h2><ul><li><p>将公共操作和域放在超类</p></li><li><p>不要使用受保护的域</p><p>一般不要使用，除protected方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用。</p></li><li><p>在覆盖方法时，不要改变预期的行为</p></li><li><p>使用多态，而非类型信息（方法参数类型不同）</p></li><li><p>不要过多地使用反射</p><p>反射机制对于编写系统程序的人来说极其实用，但通常不适于编写应用程序。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第5章-继承&quot;&gt;&lt;a href=&quot;#第5章-继承&quot; class=&quot;headerlink&quot; title=&quot;第5章 继承&quot;&gt;&lt;/a&gt;第5章 继承&lt;/h1&gt;&lt;h2 id=&quot;5-1-类、超类和子类&quot;&gt;&lt;a href=&quot;#5-1-类、超类和子类&quot; class=&quot;headerlink&quot; title=&quot;5.1 类、超类和子类&quot;&gt;&lt;/a&gt;5.1 类、超类和子类&lt;/h2&gt;&lt;p&gt;通过扩展超类定义子类时，只需指出子类与超类的不同之处。&lt;/p&gt;
&lt;p&gt;使用关键字super调用超类。
    
    </summary>
    
      <category term="Java核心技术卷Ⅰ读书笔记" scheme="https://wcxdhr.github.io/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java读书笔记系列 第4章 对象与类</title>
    <link href="https://wcxdhr.github.io/2019/03/13/Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"/>
    <id>https://wcxdhr.github.io/2019/03/13/Java读书笔记系列-第4章-对象与类/</id>
    <published>2019-03-13T12:40:18.000Z</published>
    <updated>2019-05-15T09:09:24.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第4章-对象与类"><a href="#第4章-对象与类" class="headerlink" title="第4章 对象与类"></a>第4章 对象与类</h1><h3 id="4-1-4-类之间的关系"><a href="#4-1-4-类之间的关系" class="headerlink" title="4.1.4 类之间的关系"></a>4.1.4 类之间的关系</h3><ul><li><p>依赖（uses-a）</p><p>一个类的方法操纵另一个类的对象，应尽可能减少依赖，<em>让类之间的耦合度最小</em>（Order对象使用Account对象查看信用状态）<a id="more"></a></p></li><li><p>聚合（has-a）</p><p>类A的对象包含类B的对象（Order对象包含一些Item对象）</p></li><li><p>继承（is-a）</p><p>类A扩展类B，继承类B（RushOrder类继承Order类）</p></li></ul><img src="/2019/03/13/Java读书笔记系列-第4章-对象与类/1551258991671.png"><h3 id="4-2-1-对象与对象变量"><a href="#4-2-1-对象与对象变量" class="headerlink" title="4.2.1 对象与对象变量"></a>4.2.1 对象与对象变量</h3><p><strong>对象与对象变量的区别</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date deadline;<span class="comment">//deadline是对象变量，未指向任何对象</span></span><br></pre></td></tr></table></figure><p>变量deadline不是一个对象，也没有引用对象，必须首先<strong>初始化变量</strong>。 可以使用新构造的对象初始化变量，也可以让变量引用一个已存在的对象（这样两个变量引用同一个对象）</p><p><strong>注：</strong>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。</p><p>在Java中，任何对象变量的值都是对存储在另一个地方的一个对象的引用。new操作符的返回值也是一个引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date deadline = <span class="keyword">new</span> Date();<span class="comment">//表达式new Date()构造了一个Date类型的对象，并且它的值是对新创建对象的引用。这个引用存储在变量deadline中。</span></span><br></pre></td></tr></table></figure><p><strong>所有的Java对象都是在堆中构造的</strong></p><h3 id="4-3-5-隐式参数与显式参数"><a href="#4-3-5-隐式参数与显式参数" class="headerlink" title="4.3.5 隐式参数与显式参数"></a>4.3.5 隐式参数与显式参数</h3><p>在每一个方法中，关键字this表示隐式参数。</p><h3 id="4-3-6-封装的优点"><a href="#4-3-6-封装的优点" class="headerlink" title="4.3.6 封装的优点"></a>4.3.6 封装的优点</h3><p><strong>不要返回引用可变对象的访问器方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;<span class="comment">//Bad 因为Date有一个更改器方法setTime，可以更改对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee harry = ...;</span><br><span class="line">Date d = harry.getHireDay();</span><br><span class="line"><span class="keyword">double</span> tempTime = <span class="number">10</span> * <span class="number">12345</span>;</span><br><span class="line">d.setTime(d.getTime() - (<span class="keyword">long</span>) tempTime);<span class="comment">//这里d和harry.hireDay引用同一个对象，对象已改变。</span></span><br></pre></td></tr></table></figure><img src="/2019/03/13/Java读书笔记系列-第4章-对象与类/1551336870827.png"><p>如果需要返回一个可变数据域的拷贝，应该使用clone。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Date) hireDay.clone();<span class="comment">//Ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-7-基于类的访问权限"><a href="#4-3-7-基于类的访问权限" class="headerlink" title="4.3.7 基于类的访问权限"></a>4.3.7 基于类的访问权限</h3><p>一个方法可以访问<strong>所属类的所有对象的私有数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Employee other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.equals(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(harry.equals(boss)) ...</span><br></pre></td></tr></table></figure><h3 id="4-3-9-final实例域"><a href="#4-3-9-final实例域" class="headerlink" title="4.3.9 final实例域"></a>4.3.9 final实例域</h3><p>final实例域必须在构建对象时初始化，且之后不会再被修改。</p><h2 id="4-4-静态域"><a href="#4-4-静态域" class="headerlink" title="4.4 静态域"></a>4.4 静态域</h2><p>静态域属于类，不属于任何一个独立的对象。</p><p>静态方法使用情况：</p><ul><li>一个方法不需要要访问对象状态，所需参数都是通过显式提供。</li><li>一个方法只需要访问类的静态域。</li></ul><h2 id="4-5-方法参数"><a href="#4-5-方法参数" class="headerlink" title="4.5 方法参数"></a>4.5 方法参数</h2><p>Java总是按值调用，方法得到的是所有参数值的一个拷贝，不能修改传递给它的任何参数变量的内容。</p><p>方法参数有两种类型：</p><ul><li>基本数据类型（数字、布尔型）</li><li>对象引用</li></ul><p>一个方法不能修改一个基本数据类型的参数，但可以改变对象引用的值。（方法得到的是对象引用的拷贝，对象引用及其拷贝引用同一个对象，可以由此修改所引用的对象状态）</p><img src="/2019/03/13/Java读书笔记系列-第4章-对象与类/1551339471365.png"><p>总结Java中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数</li><li>一个方法可以改变一个对象参数的状态</li><li>一个方法不能让对象参数引用一个新的对象</li></ul><h2 id="4-7-包"><a href="#4-7-包" class="headerlink" title="4.7 包"></a>4.7 包</h2><p>只能使用*导入一个包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*<span class="comment">//Ok</span></span><br><span class="line"><span class="keyword">import</span> java.*<span class="comment">//No</span></span><br><span class="line"><span class="keyword">import</span> java.*.*<span class="comment">//No</span></span><br></pre></td></tr></table></figure><p>当要使用两个包内同名的类时，将这个具体的类导入。</p><h2 id="4-9-文档注释"><a href="#4-9-文档注释" class="headerlink" title="4.9 文档注释"></a>4.9 文档注释</h2><h3 id="4-9-2-类注释"><a href="#4-9-2-类注释" class="headerlink" title="4.9.2 类注释"></a>4.9.2 类注释</h3><p>类注释必须放在import语句之后，类定义之前。</p><h3 id="4-9-3-方法注释"><a href="#4-9-3-方法注释" class="headerlink" title="4.9.3 方法注释"></a>4.9.3 方法注释</h3><p>方法注释放在所描述的方法之前。</p><h2 id="4-10-类设计技巧"><a href="#4-10-类设计技巧" class="headerlink" title="4.10 类设计技巧"></a>4.10 类设计技巧</h2><ul><li>一定要保证数据私有（不破坏封装性）</li><li>一定要对数据初始化</li><li>不要在类中使用过多的基本类型（用其他的类代替多个相关的基本类型的使用）</li><li>不是所有的域都需要独立的域访问器和域更改器</li><li>将职责过多的类进行分解</li><li>类名和方法名要能够体现它们的职责</li><li>优先使用不可变的类</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第4章-对象与类&quot;&gt;&lt;a href=&quot;#第4章-对象与类&quot; class=&quot;headerlink&quot; title=&quot;第4章 对象与类&quot;&gt;&lt;/a&gt;第4章 对象与类&lt;/h1&gt;&lt;h3 id=&quot;4-1-4-类之间的关系&quot;&gt;&lt;a href=&quot;#4-1-4-类之间的关系&quot; class=&quot;headerlink&quot; title=&quot;4.1.4 类之间的关系&quot;&gt;&lt;/a&gt;4.1.4 类之间的关系&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;依赖（uses-a）&lt;/p&gt;
&lt;p&gt;一个类的方法操纵另一个类的对象，应尽可能减少依赖，&lt;em&gt;让类之间的耦合度最小&lt;/em&gt;（Order对象使用Account对象查看信用状态）
    
    </summary>
    
      <category term="Java核心技术卷Ⅰ读书笔记" scheme="https://wcxdhr.github.io/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java读书笔记系列 第3章 Java基本程序设计结构</title>
    <link href="https://wcxdhr.github.io/2019/03/13/Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"/>
    <id>https://wcxdhr.github.io/2019/03/13/Java读书笔记系列-第3章-Java基本程序设计结构/</id>
    <published>2019-03-13T12:31:18.000Z</published>
    <updated>2019-05-15T09:03:15.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章-Java基本程序设计结构"><a href="#第3章-Java基本程序设计结构" class="headerlink" title="第3章 Java基本程序设计结构"></a>第3章 Java基本程序设计结构</h1><h3 id="3-5-2"><a href="#3-5-2" class="headerlink" title="3.5.2"></a>3.5.2</h3><p>Math.round：四舍五入（返回long类型）<a id="more"></a></p><h2 id="3-6-字符串"><a href="#3-6-字符串" class="headerlink" title="3.6  字符串"></a>3.6  字符串</h2><p>substring方法：提取子串</p><p>+：连接</p><p>String类对象：不可变字符串（修改字符串变量以引用另一个字符串），优点：编译器让字符串共享</p><p>equals方法：判断字符串是否相等（equalsIgnoreCase:不区分大小写）</p><p><strong>注</strong> ：==只能确定字符串是否放在同一个位置上（必然相等）</p><h3 id="3-6-5-空串与Null串"><a href="#3-6-5-空串与Null串" class="headerlink" title="3.6.5 空串与Null串"></a>3.6.5 空串与Null串</h3><p>空串长度为0，Null串str==null</p><h3 id="3-6-9-构建字符串"><a href="#3-6-9-构建字符串" class="headerlink" title="3.6.9 构建字符串"></a>3.6.9 构建字符串</h3><p>StringBuilder类：字符串构建器，适用于由较短的字符串构建字符串。</p><h2 id="3-8"><a href="#3-8" class="headerlink" title="3.8"></a>3.8</h2><h3 id="3-8-6"><a href="#3-8-6" class="headerlink" title="3.8.6"></a>3.8.6</h3><p>带标签的break语句：跳出多重循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">read_data:</span><br><span class="line"><span class="keyword">while</span>()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">break</span> read_data;</span><br><span class="line"><span class="comment">//跳出read_data所标记的循环  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-大数值"><a href="#3-9-大数值" class="headerlink" title="3.9 大数值"></a>3.9 大数值</h2><p>BigInteger </p><p>BigDecimal</p><h2 id="3-10-数组"><a href="#3-10-数组" class="headerlink" title="3.10 数组"></a>3.10 数组</h2><p><strong>初始值</strong></p><p>数字数组：0</p><p>布尔型数组：false</p><p>对象数组：null</p><p><strong>for each 循环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable : collection) statement</span><br><span class="line"><span class="comment">//example a:数组或实现了Iterable接口的类对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> element : a)</span><br><span class="line">    System.out.println(element);</span><br></pre></td></tr></table></figure><h3 id="3-10-3-数组拷贝"><a href="#3-10-3-数组拷贝" class="headerlink" title="3.10.3 数组拷贝"></a>3.10.3 数组拷贝</h3><p>一个数组变量拷贝给另一个数组变量：两个变量引用同一个数组</p><img src="/2019/03/13/Java读书笔记系列-第3章-Java基本程序设计结构/1551256677685.png">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第3章-Java基本程序设计结构&quot;&gt;&lt;a href=&quot;#第3章-Java基本程序设计结构&quot; class=&quot;headerlink&quot; title=&quot;第3章 Java基本程序设计结构&quot;&gt;&lt;/a&gt;第3章 Java基本程序设计结构&lt;/h1&gt;&lt;h3 id=&quot;3-5-2&quot;&gt;&lt;a href=&quot;#3-5-2&quot; class=&quot;headerlink&quot; title=&quot;3.5.2&quot;&gt;&lt;/a&gt;3.5.2&lt;/h3&gt;&lt;p&gt;Math.round：四舍五入（返回long类型）
    
    </summary>
    
      <category term="Java核心技术卷Ⅰ读书笔记" scheme="https://wcxdhr.github.io/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Bupt OJ-302. 网络传输-网研14</title>
    <link href="https://wcxdhr.github.io/2018/03/20/Bupt-OJ-302-%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93-%E7%BD%91%E7%A0%9414/"/>
    <id>https://wcxdhr.github.io/2018/03/20/Bupt-OJ-302-网络传输-网研14/</id>
    <published>2018-03-20T05:32:28.000Z</published>
    <updated>2019-05-15T09:12:06.607Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/03/20/Bupt-OJ-302-网络传输-网研14/269.png"><p>刚开始拿Floyd做，直接内存和时间都超过，而且是错的，后来改成Dijkstra加全排列即通过。<a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000001</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>][<span class="number">1001</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    d[i][j]=j==i?<span class="number">0</span>:INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,m=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)<span class="keyword">if</span>(!a[k]&amp;&amp;d[i][k]&lt;=m)m=d[i][x=k];</span><br><span class="line">a[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)d[i][k]=min(d[i][k],d[i][x]+v[x][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> m,aim[<span class="number">11</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">   v[i][j]=INF;</span><br><span class="line">v[i][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v1,v2,e;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;v1,&amp;v2,&amp;e);</span><br><span class="line">v[v1][v2]=v[v2][v1]=e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;aim[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> sum=INF;</span><br><span class="line">aim[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">    dijkstra(aim[i]);</span><br><span class="line">sort(aim+<span class="number">1</span>,aim+k+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)tmp+=d[aim[i<span class="number">-1</span>]][aim[i]];</span><br><span class="line"><span class="keyword">if</span>(tmp&lt;sum)sum=tmp;</span><br><span class="line">&#125;<span class="keyword">while</span>(next_permutation(aim+<span class="number">1</span>,aim+k+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/03/20/Bupt-OJ-302-网络传输-网研14/269.png&quot;&gt;
&lt;p&gt;刚开始拿Floyd做，直接内存和时间都超过，而且是错的，后来改成Dijkstra加全排列即通过。
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Bupt OJ" scheme="https://wcxdhr.github.io/tags/Bupt-OJ/"/>
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Bupt OJ-306. Python List-计算机一2014</title>
    <link href="https://wcxdhr.github.io/2018/03/18/Bupt-OJ-306-Python-List-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%802014/"/>
    <id>https://wcxdhr.github.io/2018/03/18/Bupt-OJ-306-Python-List-计算机一2014/</id>
    <published>2018-03-18T11:11:37.000Z</published>
    <updated>2019-05-15T09:11:45.698Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/03/18/Bupt-OJ-306-Python-List-计算机一2014/273.png"><p>思路：利用vector和map配合进行模拟即可。<a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> n,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    a[i].clear();</span><br><span class="line">b.clear();</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">string</span> line,snum,opp;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c)&amp;&amp;c!=<span class="string">'='</span>&amp;&amp;c!=<span class="string">'.'</span>&amp;&amp;c!=<span class="string">'['</span>)<span class="comment">//得到List名 </span></span><br><span class="line">   snum.insert(snum.end(),<span class="number">1</span>,c);</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'='</span>)&#123;<span class="comment">//清空 </span></span><br><span class="line"><span class="keyword">if</span>(!b.count(snum))b[snum]=cnt++;</span><br><span class="line"><span class="keyword">else</span> a[b[snum]].clear();</span><br><span class="line">getline(<span class="built_in">cin</span>,line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'.'</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c)&amp;&amp;c!=<span class="string">'('</span>)</span><br><span class="line">opp.insert(opp.end(),<span class="number">1</span>,c);</span><br><span class="line"><span class="keyword">if</span>(opp[<span class="number">0</span>]==<span class="string">'a'</span>)&#123;<span class="comment">//插入 </span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">a[b[snum]].push_back(x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//排序 </span></span><br><span class="line">sort(a[b[snum]].begin(),a[b[snum]].end());</span><br><span class="line">&#125;</span><br><span class="line">getline(<span class="built_in">cin</span>,line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//查找 </span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(x&lt;a[b[snum]].size())<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[b[snum]][x]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"ERROR\n"</span>);</span><br><span class="line">getline(<span class="built_in">cin</span>,line);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/03/18/Bupt-OJ-306-Python-List-计算机一2014/273.png&quot;&gt;
&lt;p&gt;思路：利用vector和map配合进行模拟即可。
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Bupt OJ" scheme="https://wcxdhr.github.io/tags/Bupt-OJ/"/>
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Bupt OJ-305. 网络的核-计算机一2014</title>
    <link href="https://wcxdhr.github.io/2018/03/17/Bupt-OJ-305-%E7%BD%91%E7%BB%9C%E7%9A%84%E6%A0%B8-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%802014/"/>
    <id>https://wcxdhr.github.io/2018/03/17/Bupt-OJ-305-网络的核-计算机一2014/</id>
    <published>2018-03-17T14:54:43.000Z</published>
    <updated>2019-05-15T09:11:28.229Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/03/17/Bupt-OJ-305-网络的核-计算机一2014/272.png"><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">55</span>];</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">55</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    d[j]=j==i?<span class="number">0</span>:n*n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,m=n*n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)<span class="keyword">if</span>(!v[k]&amp;&amp;d[k]&lt;=m)m=d[x=k];</span><br><span class="line">v[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)d[k]=min(d[k],d[x]+a[x][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    ans+=d[j];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">55</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    a[i][j]=n;</span><br><span class="line">a[i][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">a[v][u]=a[u][v]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">ans[i]=dijkstra(i,n);</span><br><span class="line"><span class="keyword">int</span> best=<span class="number">1</span>,mini=n*n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ans[i]&lt;mini)&#123;</span><br><span class="line">mini=ans[i];</span><br><span class="line">best=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,best);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/03/17/Bupt-OJ-305-网络的核-计算机一2014/272.png&quot;&gt;
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Bupt OJ" scheme="https://wcxdhr.github.io/tags/Bupt-OJ/"/>
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Bupt OJ-304. 旋转图像-计算机一2014</title>
    <link href="https://wcxdhr.github.io/2018/03/17/Bupt-OJ-304-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%802014/"/>
    <id>https://wcxdhr.github.io/2018/03/17/Bupt-OJ-304-旋转图像-计算机一2014/</id>
    <published>2018-03-17T14:51:54.000Z</published>
    <updated>2019-05-15T09:11:12.506Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/03/17/Bupt-OJ-304-旋转图像-计算机一2014/271.png"><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"data.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,al;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;al);</span><br><span class="line"><span class="keyword">if</span>(!al)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(al==<span class="number">90</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(al==<span class="number">180</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/03/17/Bupt-OJ-304-旋转图像-计算机一2014/271.png&quot;&gt;
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Bupt OJ" scheme="https://wcxdhr.github.io/tags/Bupt-OJ/"/>
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Bupt OJ-303. 众数-计算机一2014</title>
    <link href="https://wcxdhr.github.io/2018/03/17/Bupt-OJ-303-%E4%BC%97%E6%95%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%802014/"/>
    <id>https://wcxdhr.github.io/2018/03/17/Bupt-OJ-303-众数-计算机一2014/</id>
    <published>2018-03-17T14:35:37.000Z</published>
    <updated>2019-05-15T09:10:56.994Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/03/17/Bupt-OJ-303-众数-计算机一2014/270.png"><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;M;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">M.clear();</span><br><span class="line"><span class="keyword">int</span> n,mini;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">if</span>(!M.count(a[i]))M[a[i]]=<span class="number">0</span>;</span><br><span class="line">M[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">mini=a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(M[a[i]]&gt;M[mini])</span><br><span class="line">mini=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,mini);</span><br><span class="line"><span class="keyword">if</span>(T)<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/03/17/Bupt-OJ-303-众数-计算机一2014/270.png&quot;&gt;
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Bupt OJ" scheme="https://wcxdhr.github.io/tags/Bupt-OJ/"/>
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>UVa 101 - The Blocks Problem</title>
    <link href="https://wcxdhr.github.io/2018/03/12/UVa-101-The-Blocks-Problem/"/>
    <id>https://wcxdhr.github.io/2018/03/12/UVa-101-The-Blocks-Problem/</id>
    <published>2018-03-12T10:37:21.000Z</published>
    <updated>2019-03-13T09:34:48.012Z</updated>
    
    <content type="html"><![CDATA[<p>木块问题，用vector保存木块堆，与书上代码差不多。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">25</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;wood[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> &amp;h,<span class="keyword">int</span> &amp;w)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;n;w++)</span><br><span class="line">   <span class="keyword">for</span>(h=<span class="number">0</span>;h&lt;wood[w].size();h++)</span><br><span class="line">      <span class="keyword">if</span>(wood[w][h]==a)<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h+<span class="number">1</span>;i&lt;wood[w].size();i++)</span><br><span class="line">wood[wood[w][i]].push_back(wood[w][i]);</span><br><span class="line">wood[w].resize(h+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a_moveto_b</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> ha,<span class="keyword">int</span> wa,<span class="keyword">int</span> wb)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=ha;i&lt;wood[wa].size();i++)</span><br><span class="line">wood[wb].push_back(wood[wa][i]);</span><br><span class="line">wood[wa].resize(ha);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("dataout.txt","w",stdout);</span></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">string</span> str1,str2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)wood[i].push_back(i);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str1&gt;&gt;a&gt;&gt;str2&gt;&gt;b&amp;&amp;str1[<span class="number">0</span>]!=<span class="string">'q'</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> wa,wb,ha,hb;</span><br><span class="line">find(a,ha,wa);</span><br><span class="line">find(b,hb,wb);</span><br><span class="line"><span class="keyword">if</span>(wa==wb)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(str1[<span class="number">0</span>]==<span class="string">'m'</span>)&#123;</span><br><span class="line">reset(a,wa,ha);</span><br><span class="line"><span class="keyword">if</span>(str2[<span class="number">1</span>]==<span class="string">'n'</span>)reset(b,wb,hb);</span><br><span class="line">a_moveto_b(a,b,ha,wa,wb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str2[<span class="number">1</span>]==<span class="string">'n'</span>)reset(b,wb,hb);</span><br><span class="line">a_moveto_b(a,b,ha,wa,wb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d:"</span>,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;wood[i].size();j++)<span class="built_in">printf</span>(<span class="string">" %d"</span>,wood[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;木块问题，用vector保存木块堆，与书上代码差不多。&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Uva 1590</title>
    <link href="https://wcxdhr.github.io/2018/03/10/uva-1590/"/>
    <id>https://wcxdhr.github.io/2018/03/10/uva-1590/</id>
    <published>2018-03-10T14:02:12.000Z</published>
    <updated>2019-03-13T09:34:57.229Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> ip[<span class="number">1005</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">4</span>][<span class="number">9</span>],str2[<span class="number">4</span>][<span class="number">9</span>],mask[<span class="number">4</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minAdr</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">8</span>,temp=ip[i][j];</span><br><span class="line"><span class="keyword">while</span>(k--)&#123;</span><br><span class="line">str2[j][k]=temp%<span class="number">2</span>;</span><br><span class="line">temp=temp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">8</span>;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag)</span><br><span class="line"><span class="keyword">if</span>(str2[j][k]!=str1[j][k])&#123;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="keyword">if</span>(i)str1[j][k]=mask[j][k]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> str1[j][k]=str2[j][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("dataout.txt","w",stdout);</span></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m)!=EOF)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;ip[i][j]);</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">str1[i][j]=mask[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">minAdr(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">ip[<span class="number">0</span>][j]=ip[<span class="number">1</span>][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">8</span>;k++)&#123;</span><br><span class="line">ip[<span class="number">0</span>][j]+=(str1[j][k]&lt;&lt;(<span class="number">7</span>-k));</span><br><span class="line">ip[<span class="number">1</span>][j]+=(mask[j][k]&lt;&lt;(<span class="number">7</span>-k));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)<span class="built_in">printf</span>(<span class="string">"%d.%d.%d.%d\n"</span>,ip[i][<span class="number">0</span>],ip[i][<span class="number">1</span>],ip[i][<span class="number">2</span>],ip[i][<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
</feed>
