<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WCXDHR Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wcxdhr.github.io/"/>
  <updated>2019-05-15T08:56:16.378Z</updated>
  <id>https://wcxdhr.github.io/</id>
  
  <author>
    <name>WCXDHR</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android开发艺术探索笔记系列-第3章-View的事件体系</title>
    <link href="https://wcxdhr.github.io/2019/05/15/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"/>
    <id>https://wcxdhr.github.io/2019/05/15/Android开发艺术探索笔记系列-第3章-View的事件体系/</id>
    <published>2019-05-15T08:47:40.000Z</published>
    <updated>2019-05-15T08:56:16.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="View的事件体系"><a href="#View的事件体系" class="headerlink" title="View的事件体系"></a>View的事件体系</h1><h2 id="View基础知识"><a href="#View基础知识" class="headerlink" title="View基础知识"></a>View基础知识</h2><h3 id="什么是View"><a href="#什么是View" class="headerlink" title="什么是View"></a>什么是View</h3><p>View是Android中所有控件的基类。</p><p>ViewGroup内部包含了一组View，它也继承自View。这种关系形成了View树的概念。<a id="more"></a></p><h3 id="View的位置参数"><a href="#View的位置参数" class="headerlink" title="View的位置参数"></a>View的位置参数</h3><p>四个属性：</p><ul><li>top 左上角纵坐标</li><li>left 左上角横坐标</li><li>right 右下角横坐标</li><li>bottom 右下角纵坐标</li></ul><p>以上都是相对坐标，相对于父容器来说。</p><p><strong>x轴和y轴方向分别为右和下（第四象限）</strong></p><img src="/2019/05/15/Android开发艺术探索笔记系列-第3章-View的事件体系/1557129414312.png"><p>Android3.0之后，View增加了几个额外参数：</p><ul><li>x 和 y：View左上角坐标</li><li>translationX和translationY：View左上角相对于父容器的偏移量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = left + translationX</span><br><span class="line">y = top + translationY</span><br></pre></td></tr></table></figure><p>View在平移过程中，top和left是原始左上角的位置信息，不会发生改变。translationX/Y是平移距离，x/y是View的左上角位置。</p><p>参考：<a href="https://blog.csdn.net/wxv111/article/details/50901199" target="_blank" rel="noopener">https://blog.csdn.net/wxv111/article/details/50901199</a></p><h3 id="MotionEvent和TouchSlop"><a href="#MotionEvent和TouchSlop" class="headerlink" title="MotionEvent和TouchSlop"></a>MotionEvent和TouchSlop</h3><p><strong>MotionEvent</strong></p><p>手指接触屏幕产生的一系列事件中，有以下典型事件：</p><ul><li>ACTION_DOWN：手指刚接触屏幕</li><li>ACTION_MOVE：手指在屏幕上移动</li><li>ACTION_UP：手指从屏幕上松开的一瞬间</li></ul><p>一次手指触摸屏幕的行为会触发一系列点击事件，考虑以下几种情况：</p><ul><li>点击屏幕后离开松开：DOWN-&gt;UP</li><li>点击屏幕滑动再松开：DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP</li></ul><p>通过MotionEvent对象可以得到点击事件发生的x和y坐标：</p><p>getX/getY返回当前相对于当前View左上角的x和y坐标，getRawX/getRawY返回相对手机屏幕左上角的x和y坐标。</p><p><strong>TouchSlop</strong></p><p>系统所能识别的滑动的最小距离。这是一个常量，和设备有关。</p><p>ViewConfiguration.get(getContext()).getScaledTouchSlop()可以获得这个常量。</p><p>在处理滑动时，可以利用这个常量做一些过滤。</p><p>源码frameworks/base/core/res/res/values/config.xml中可以找到这个常量的定义。</p><h3 id="VelocityTracker、GestureDetector和Scroller"><a href="#VelocityTracker、GestureDetector和Scroller" class="headerlink" title="VelocityTracker、GestureDetector和Scroller"></a>VelocityTracker、GestureDetector和Scroller</h3><p><strong>VelocityTracker</strong></p><p>速度追踪，用于追踪手指在滑动过程中的速度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VelocityTracker velocityTracker = VelocityTracker.obtain();</span><br><span class="line">velocityTracker.addMovement(event);<span class="comment">//在View的onTouchEvent方法中追踪当前单击事件速度</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取当前滑动速度</span></span><br><span class="line">velocityTracker.computeCurrentVelocity(<span class="number">1000</span>);<span class="comment">//获取速度前先计算速度，参数为时间，单位ms</span></span><br><span class="line"><span class="keyword">int</span> xVelocity = (<span class="keyword">int</span>) velocityTracker.getXVelocity();</span><br><span class="line"><span class="keyword">int</span> yVelocity = (<span class="keyword">int</span>) velocityTracker.getYVelocity();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用完成后，回收内存</span></span><br><span class="line">velocityTracker.clear();</span><br><span class="line">velocityTracker.recycle();</span><br></pre></td></tr></table></figure><p><strong>GestureDetector</strong></p><p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。</p><ul><li><p>首先，创建一个GestureDetector对象并实现OnGestureListener接口，根据需要还可以实现其它接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector mGestureDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>);</span><br><span class="line">mGestureDetector.setIsLongpressEnabled(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>接着，接管目标View的onTouchEvent方法，在待监听View的onTouchEvent方法中添加实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> consume = mGestureDetector.onTouchEvent(event);</span><br><span class="line"><span class="keyword">return</span> consume;</span><br></pre></td></tr></table></figure></li></ul><p>详解：<a href="https://www.gcssloop.com/customview/gestruedector" target="_blank" rel="noopener">https://www.gcssloop.com/customview/gestruedector</a></p><p><strong>注</strong>：建议只是监听滑动相关的，在onTouchEvent中实现，如果监听双击行为，使用GestureDetector。</p><p><strong>Scroller</strong></p><p>弹性滑动对象，用于实现View的弹性滑动。（View的scrollTo/scrollBy方法来进行滑动时，过程瞬间完成，没有过渡效果）</p><p>Scroller需要和View的computeScroll方法一起配合使用。</p><h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><h3 id="使用scrollTo-scrollBy"><a href="#使用scrollTo-scrollBy" class="headerlink" title="使用scrollTo/scrollBy"></a>使用scrollTo/scrollBy</h3><p>scrollTo实现了基于所传递参数的绝对滑动。scrollBy调用scrollTo，实现了基于当前位置的相对滑动。</p><p>滑动过程中View有两个属性mScrollX和mScrollY，在滑动过程中，总是等于View的左/上边缘和View内容左/上边缘在水平/竖直方向的距离。</p><p>使用scrollTo和scrollBy时，只能将View的内容滑动，不能将View本身移动。</p><img src="/2019/05/15/Android开发艺术探索笔记系列-第3章-View的事件体系/1557733283447.png"><h3 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h3><p>（View动画省略）</p><p>现在使用属性动画。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(targetView, <span class="string">"translationX"</span>, <span class="number">0</span>, <span class="number">100</span>).setDuration(<span class="number">100</span>).start();</span><br></pre></td></tr></table></figure><h3 id="改变布局参数"><a href="#改变布局参数" class="headerlink" title="改变布局参数"></a>改变布局参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line">MarginLayoutParams params = (MarginLayoutParams)mButton1.getLayoutParams();</span><br><span class="line">params.width += <span class="number">100</span>;</span><br><span class="line">params.leftMargin += <span class="number">100</span>;</span><br><span class="line">mButton.requestLayout();<span class="comment">//或mButton1.setLayoutParams(params);</span></span><br></pre></td></tr></table></figure><h3 id="三种滑动方式对比"><a href="#三种滑动方式对比" class="headerlink" title="三种滑动方式对比"></a>三种滑动方式对比</h3><ul><li><p>使用scrollTo/scrollBy：操作简单，适合对View内容的滑动</p><p>View提供的原生方法，专门用于View的滑动，可以比较方便地实现滑动效果而不影响内部元素的单击事件。缺点：只能滑动View的内容，不能滑动View本身。</p></li><li><p>使用动画：操作简单，适用于没有交互的View和实现复杂的动画效果</p><p>属性动画没有明显缺点。优点是一些复杂的效果必须通过动画实现。</p></li><li><p>改变布局参数：操作稍微复杂，适用于有交互的View</p><p>使用起来比较麻烦，也没有明显缺点。主要适用对象是一些具有交互性的View。</p></li></ul><h2 id="弹性滑动"><a href="#弹性滑动" class="headerlink" title="弹性滑动"></a>弹性滑动</h2><p>渐进式滑动，实现方法的共同思想是：将一次大的滑动分成若干次小的滑动并在一个时间段内完成。</p><h3 id="使用Scroller"><a href="#使用Scroller" class="headerlink" title="使用Scroller"></a>使用Scroller</h3><p><a href="https://www.jianshu.com/p/cce0d5fc8c35" target="_blank" rel="noopener">https://www.jianshu.com/p/cce0d5fc8c35</a></p><h3 id="通过动画"><a href="#通过动画" class="headerlink" title="通过动画"></a>通过动画</h3><p>在onAnimationnUpdate中加上scrollTo方法进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> deltaX = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">final</span> ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>,<span class="number">1</span>).setDuration(<span class="number">1000</span>);</span><br><span class="line">animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> fraction = animator.getAnimatedFraction();</span><br><span class="line">        mButton.scrollTo(startX + (<span class="keyword">int</span>) (deltaX * fraction), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure><h3 id="使用延时策略"><a href="#使用延时策略" class="headerlink" title="使用延时策略"></a>使用延时策略</h3><p>使用Handler或View的postDelayed方法。</p><h2 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h2><p><a href="https://blog.csdn.net/carson_ho/article/details/54136311" target="_blank" rel="noopener">https://blog.csdn.net/carson_ho/article/details/54136311</a></p><p>这篇博客写得比较清楚。</p><h2 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h2><p>常见滑动冲突场景：</p><ul><li>场景1——外部滑动方向和内部滑动方向不一致</li><li>场景2——外部滑动方向和内部滑动方向一致</li><li>场景3——上面两种情况的嵌套</li></ul><img src="/2019/05/15/Android开发艺术探索笔记系列-第3章-View的事件体系/1557909679329.png"><p><img src="D:\Desktop\学\一\項目\Android开发艺术探索\1557909679329.png" alt=""></p><h3 id="处理规则"><a href="#处理规则" class="headerlink" title="处理规则"></a>处理规则</h3><p>场景1：用户左右滑动时，需要外部的View拦截点击事件，用户上下滑动时，需要让内部View拦截点击事件。一般可以根据水平和竖直方向滑动的距离来判断方向。</p><p>场景2：在业务上找突破点。</p><p>场景3：同上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;View的事件体系&quot;&gt;&lt;a href=&quot;#View的事件体系&quot; class=&quot;headerlink&quot; title=&quot;View的事件体系&quot;&gt;&lt;/a&gt;View的事件体系&lt;/h1&gt;&lt;h2 id=&quot;View基础知识&quot;&gt;&lt;a href=&quot;#View基础知识&quot; class=&quot;headerlink&quot; title=&quot;View基础知识&quot;&gt;&lt;/a&gt;View基础知识&lt;/h2&gt;&lt;h3 id=&quot;什么是View&quot;&gt;&lt;a href=&quot;#什么是View&quot; class=&quot;headerlink&quot; title=&quot;什么是View&quot;&gt;&lt;/a&gt;什么是View&lt;/h3&gt;&lt;p&gt;View是Android中所有控件的基类。&lt;/p&gt;
&lt;p&gt;ViewGroup内部包含了一组View，它也继承自View。这种关系形成了View树的概念。
    
    </summary>
    
      <category term="Android开发艺术探索笔记" scheme="https://wcxdhr.github.io/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索笔记系列-第1章-Activity的生命周期和启动模式</title>
    <link href="https://wcxdhr.github.io/2019/04/24/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC1%E7%AB%A0-Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://wcxdhr.github.io/2019/04/24/Android开发艺术探索笔记系列-第1章-Activity的生命周期和启动模式/</id>
    <published>2019-04-24T08:21:46.000Z</published>
    <updated>2019-05-15T08:57:11.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Activity的生命周期分析"><a href="#Activity的生命周期分析" class="headerlink" title="Activity的生命周期分析"></a>Activity的生命周期分析</h2><img src="/2019/04/24/Android开发艺术探索笔记系列-第1章-Activity的生命周期和启动模式/1555903104817.png"><h3 id="正常情况下的生命周期"><a href="#正常情况下的生命周期" class="headerlink" title="正常情况下的生命周期"></a>正常情况下的生命周期</h3><p>如上图中心线所示。<a id="more"></a></p><p>Activity切换时，旧Activity先onPause，新Activity再启动。</p><p>onPause执行完成后新Activity才能Resume，因此onPause中不能做重量级操作。（onStop中可以做稍微重量级一些的工作，也不能太耗时）</p><h3 id="异常情况下的生命周期"><a href="#异常情况下的生命周期" class="headerlink" title="异常情况下的生命周期"></a>异常情况下的生命周期</h3><p>异常情况指Activity被系统回收或当前设备Configuration发生改变。</p><h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><p><strong>资源相关的系统配置发生改变导致Activity被杀死并重新创建</strong></p><p>例如旋转屏幕</p><p><img src="1555913057138.png" alt=""></p><p>在onStop之前调用onSaveInstanceState来保存Activity状态。（可能在onPause之前，也可能在onPause之后）。</p><p>Activity重新创建后，系统会调用onRestoreInstanceState（在onStart之后），并将onSaveInstanceState保存的Bundle对象作为参数传给onCreate和onRestoreInstanceState。</p><p>系统自动做的恢复工作：当前Activity的视图结构（例如文本框中的输入数据，ListView滚动的位置）。</p><p>保存数据和恢复数据采用的是委托思想。Activity委托Window，Window再委托它上面的顶级容器来保存数据（一般是一个ViewGroup，很可能是DecorView）。顶级容器再一一通知它的子元素来保存数据。</p><p><strong>注：onRestoreInstanceState会对Bundl判空，onCreate不会</strong></p><h4 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h4><p><strong>系统内存不足导致低优先级的Activity被杀死</strong></p><p><strong>注：</strong> 当系统配置发生改变后，若不想系统重新创建Activity，可以给Activity指定configChanges属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//example</span><br><span class="line">android:configChanges="orientation"</span><br></pre></td></tr></table></figure><p>这样屏幕方向改变时，Activity不会被销毁重建，而是系统调用Activity的onConfigurationChanged方法。</p><h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><h3 id="Activity的LaunchMode"><a href="#Activity的LaunchMode" class="headerlink" title="Activity的LaunchMode"></a>Activity的LaunchMode</h3><ul><li><p><strong>standard 标准模式</strong></p><p>默认模式，重复创建。</p></li><li><p><strong>singleTop 栈顶复用模式</strong></p><p>若Activity位于任务栈的栈顶，不会重新创建，而是调用onNewIntent方法。否则会重新创建。</p></li><li><p><strong>singleTask 栈内复用模式</strong></p><p>只要Activity在一个栈中存在，则多次启动不会重新创建实例。注：该模式具有clearTop效果，栈内所有在上面的Activity会全部出栈。</p></li><li><p><strong>singleInstance 单实例模式</strong></p><p>加强版的singleTask，Activity只能单独地位于一个任务栈中。</p></li></ul><p><strong>任务栈：TaskAffinity标识了所需要的任务栈的名字</strong></p><p><strong>给Activity指定启动模式的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line">android:launchMode = <span class="string">"singleTask"</span></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br></pre></td></tr></table></figure><p>方法二的优先级高于方法一，限定范围有所不同。</p><h3 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h3><p>一些常用的标记位：</p><ul><li><p>FLAGS_ACTIVITY_NEW_TASK</p><p>指定singleTask启动模式</p></li><li><p>FLAGS_ACTIVITY_SINGLE_TOP</p><p>指定singleTop启动模式</p></li><li><p>FLAGS_ACTIVITY_CLEAR_TOP</p><p>清除栈内该Activity上面的Activity（出栈）</p></li><li><p>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</p><p>Activity不会出现在历史Activity列表中</p></li></ul><h2 id="IntentFilter的匹配规则"><a href="#IntentFilter的匹配规则" class="headerlink" title="IntentFilter的匹配规则"></a>IntentFilter的匹配规则</h2><p>启动Activity的隐式调用中，需要Intent能够匹配目标组件的IntentFilter中所设置的过滤信息。</p><p>IntentFilter中的过滤信息有action、category、data。</p><p>匹配时需要全部匹配，有多个intent-filter时，能匹配任意一组即可启动。</p><p><strong>action</strong></p><p>要求Intent中action存在且必须至少有一个和过滤规则中的其中一个action相同，区分大小写。</p><p><strong>category</strong></p><p>Intent中可以没有category（这时category默认为“android.intent.category.DEFAULT“，只要intent-filter中有相应category即可接收隐式调用）。</p><p>一旦有category每一个都要与过滤规则中的其中一个category相同。</p><p><strong>data</strong></p><p>与action类似。</p><p>Data属性通常用来向Action属性提供操作的数据。</p><p><strong>注：Service建议尽量使用显式调用</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Activity的生命周期分析&quot;&gt;&lt;a href=&quot;#Activity的生命周期分析&quot; class=&quot;headerlink&quot; title=&quot;Activity的生命周期分析&quot;&gt;&lt;/a&gt;Activity的生命周期分析&lt;/h2&gt;&lt;img src=&quot;/2019/04/24/Android开发艺术探索笔记系列-第1章-Activity的生命周期和启动模式/1555903104817.png&quot;&gt;
&lt;h3 id=&quot;正常情况下的生命周期&quot;&gt;&lt;a href=&quot;#正常情况下的生命周期&quot; class=&quot;headerlink&quot; title=&quot;正常情况下的生命周期&quot;&gt;&lt;/a&gt;正常情况下的生命周期&lt;/h3&gt;&lt;p&gt;如上图中心线所示。
    
    </summary>
    
      <category term="Android开发艺术探索笔记" scheme="https://wcxdhr.github.io/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java读书笔记系列 第8章 泛型程序设计</title>
    <link href="https://wcxdhr.github.io/2019/03/15/Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC8%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://wcxdhr.github.io/2019/03/15/Java读书笔记系列-第8章-泛型程序设计/</id>
    <published>2019-03-15T02:21:40.000Z</published>
    <updated>2019-03-15T09:55:31.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第8章-泛型程序设计"><a href="#第8章-泛型程序设计" class="headerlink" title="第8章 泛型程序设计"></a>第8章 泛型程序设计</h1><p>泛型对于集合类尤其有用，ArrayList就是一个无处不在的类。<a id="more"></a></p><h2 id="8-2-定义简单泛型类"><a href="#8-2-定义简单泛型类" class="headerlink" title="8.2 定义简单泛型类"></a>8.2 定义简单泛型类</h2><p>一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;//<span class="title">T</span>是类型变量</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：JAVA库中一般使用E表示集合的元素类型，K和V分别表示表的关键字与值的类型。T（有时也可以用临近的U和S）表示”任意类型“</strong></p><h2 id="8-3-泛型方法"><a href="#8-3-泛型方法" class="headerlink" title="8.3 泛型方法"></a>8.3 泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用该方法</span></span><br><span class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"dddd"</span>,<span class="string">"aaaa"</span>);<span class="comment">//&lt;String&gt;可以省略</span></span><br></pre></td></tr></table></figure><h2 id="8-4-类型变量的限定"><a href="#8-4-类型变量的限定" class="headerlink" title="8.4 类型变量的限定"></a>8.4 类型变量的限定</h2><p>有时，类或方法需要对类型变量加以约束。例如将T限制为实现了Comparable接口的类，可恶意通过对类型变量T设置限定实现这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span>...</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends BoundingType&gt;<span class="comment">//表示T是绑定类型的子类型，既可以是接口也可以是类</span></span><br></pre></td></tr></table></figure><p>一个类型变量或通配符可以有多个限定，中间用&amp;分隔。</p><h2 id="8-5-泛型代码和虚拟机"><a href="#8-5-泛型代码和虚拟机" class="headerlink" title="8.5 泛型代码和虚拟机"></a>8.5 泛型代码和虚拟机</h2><blockquote><p><a href="https://blog.csdn.net/briblue/article/details/76736356" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/76736356</a>  这篇博客讲的类型擦除更容易理解。</p></blockquote><h3 id="8-5-3-翻译泛型方法"><a href="#8-5-3-翻译泛型方法" class="headerlink" title="8.5.3 翻译泛型方法"></a>8.5.3 翻译泛型方法</h3><p>有关Java泛型转换的事实：</p><ul><li>虚拟机中没有泛型，只有普通的类和方法。</li><li>所有的类型参数都用它们的限定类型替换。</li><li>桥方法被合成来保持多态。</li><li>为保持类型安全性，必要时插入强制类型转换。</li></ul><h3 id="8-5-4-调用遗留代码"><a href="#8-5-4-调用遗留代码" class="headerlink" title="8.5.4 调用遗留代码"></a>8.5.4 调用遗留代码</h3><p>注解（annotation）可以使警告消失：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注解放在生成警告的代码所在的方法前。</p><h2 id="8-6-约束与局限性"><a href="#8-6-约束与局限性" class="headerlink" title="8.6 约束与局限性"></a>8.6 约束与局限性</h2><p>以下大多数限制都是由类型擦除引起的。</p><h3 id="8-6-1-不能用基本类型实例化类型参数"><a href="#8-6-1-不能用基本类型实例化类型参数" class="headerlink" title="8.6.1 不能用基本类型实例化类型参数"></a>8.6.1 不能用基本类型实例化类型参数</h3><p>没有Pair&lt;double&gt;，只有Pair&lt;Double&gt;，原因是类型擦除。擦除后Pair类含有Object类型的域，而Object不能存储double值。</p><h3 id="8-6-2-运行时类型查询只适用于原始类型"><a href="#8-6-2-运行时类型查询只适用于原始类型" class="headerlink" title="8.6.2 运行时类型查询只适用于原始类型"></a>8.6.2 运行时类型查询只适用于原始类型</h3><p>虚拟机中的对象总有一个特定的非泛型类型。因此，所有类型查询只产生原始类型。</p><p>getClass方法也总是 返回原始类型。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair = ...;</span><br><span class="line">Pair&lt;Employee&gt; employeePair = ...;</span><br><span class="line"><span class="keyword">if</span>(stringPair.geetClass() == employeePair.getClass())<span class="comment">//相等，两次调用都返回Pair.class</span></span><br></pre></td></tr></table></figure><h3 id="8-6-3-不能创建参数化类型的数组"><a href="#8-6-3-不能创建参数化类型的数组" class="headerlink" title="8.6.3 不能创建参数化类型的数组"></a>8.6.3 不能创建参数化类型的数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//Error</span></span><br></pre></td></tr></table></figure><h3 id="8-6-4-Varargs-警告"><a href="#8-6-4-Varargs-警告" class="headerlink" title="8.6.4 Varargs 警告"></a>8.6.4 Varargs 警告</h3><p>向参数个数可变的方法传递一个泛型类型的实例。</p><p>考虑下面方法，参数个数是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; coll, T... ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (t : ts) coll.add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑以下调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Pair&lt;String&gt;&gt; table = ...;</span><br><span class="line">Pair&lt;String&gt; pair1 = ...;</span><br><span class="line">Pair&lt;String&gt; pair2 = ...;</span><br><span class="line">addAll(table, pair1, pair2);</span><br></pre></td></tr></table></figure><p>为了调用这个方法，Java虚拟机必须建立一个Pair&lt;String&gt;数组，这就违反了前面的规则。不过，在这种情况下，规则有所放松，只会得到一个警告，而不是错误。</p><p>有两种方法来抑制这个警告。</p><ul><li>为包含addAll调用的方法增加注解@SuppressWarnings(“unchecked”)</li><li>在Java SE 7中，还可以用@SafeVarargs直接标注addAll方法</li></ul><h3 id="8-6-5-不能实例化类型变量"><a href="#8-6-5-不能实例化类型变量" class="headerlink" title="8.6.5 不能实例化类型变量"></a>8.6.5 不能实例化类型变量</h3><p>不能使用像new T(…)，new T[…]或T.class这样的表达式中的类型变量。</p><p>类型擦除会将T改变为Object（本意不会想调用new Object() )</p><p>在Java SE 8之后，最好的解决方法是让调用者提供一个构造器表达式。</p><p>以下省略。</p><h3 id="8-6-6-不能构造泛型数组"><a href="#8-6-6-不能构造泛型数组" class="headerlink" title="8.6.6 不能构造泛型数组"></a>8.6.6 不能构造泛型数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T[] a) &#123;T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>];...&#125;<span class="comment">//Error</span></span><br></pre></td></tr></table></figure><p>类型擦除会让这个方法永远构造Comparable[2]数组。</p><h3 id="8-6-7-泛型类的静态上下文中类型变量无效"><a href="#8-6-7-泛型类的静态上下文中类型变量无效" class="headerlink" title="8.6.7 泛型类的静态上下文中类型变量无效"></a>8.6.7 泛型类的静态上下文中类型变量无效</h3><p>不能在静态域或方法中引用类型变量。</p><p>原因：类型擦除。</p><h3 id="8-6-8-不能抛出或捕获泛型类的实例"><a href="#8-6-8-不能抛出或捕获泛型类的实例" class="headerlink" title="8.6.8 不能抛出或捕获泛型类的实例"></a>8.6.8 不能抛出或捕获泛型类的实例</h3><p>###8.6.9 可以消除对受查异常的检查 </p><p>Java异常处理的一个基本原则是必须为所有受查异常提供一个处理器。可以利用泛型消除这个限制。</p><p>具体不做介绍。总之，通过使用泛型类、擦除和@SuppressWarnings注解，就能消除Java类型系统的部分基本限制。</p><h3 id="8-6-10-注意擦除后的限制"><a href="#8-6-10-注意擦除后的限制" class="headerlink" title="8.6.10 注意擦除后的限制"></a>8.6.10 注意擦除后的限制</h3><p>当泛型类型被擦除时，无法创建引发冲突的条件。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span> </span>&#123;<span class="keyword">return</span> first.equals(value) &amp;&amp; second.equals(value)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑Pair&lt;String&gt;。从概念上讲，它有两个equals方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String)</span><span class="comment">//来自Pair&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span><span class="comment">//继承自Object</span></span></span><br></pre></td></tr></table></figure><p>方法擦除使两个方法发生冲突。补救方法是重新命名引发错误的方法。</p><p>泛型规范说明还提到另外一个原则：”要想支持擦除的转换，就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一个接口的不同参数化。“</p><h2 id="8-7-泛型类型的继承规则"><a href="#8-7-泛型类型的继承规则" class="headerlink" title="8.7 泛型类型的继承规则"></a>8.7 泛型类型的继承规则</h2><p><img src="1552637440813.png" alt=""></p><p>如图所示，无论S与T有什么关系，一般Pair&lt;S&gt;和Pair&lt;T&gt;没有任何关系。</p><p>泛型类可以扩展或实现其他的泛型类。</p><p><img src="1552638021809.png" alt=""></p><h2 id="8-8-通配符类型"><a href="#8-8-通配符类型" class="headerlink" title="8.8 通配符类型"></a>8.8 通配符类型</h2><h3 id="8-8-1-通配符概念"><a href="#8-8-1-通配符概念" class="headerlink" title="8.8.1 通配符概念"></a>8.8.1 通配符概念</h3><p>通配符类型中，允许类型参数变化。例如，通配符类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;? extends Employee&gt;</span><br></pre></td></tr></table></figure><p>表示任何泛型Pair类型，它的类型参数是Employee的子类。</p><p><img src="1552638625510.png" alt=""></p><p>Pair&lt;Manager&gt;是Pair&lt;? extends Employee&gt;的子类型。</p><p>可以为方法使用返回值，但不能提供参数。</p><h3 id="8-8-2-通配符的超类型限定"><a href="#8-8-2-通配符的超类型限定" class="headerlink" title="8.8.2 通配符的超类型限定"></a>8.8.2 通配符的超类型限定</h3><p>通配符限定可以指定一个类型限定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? <span class="keyword">super</span> Manager</span><br></pre></td></tr></table></figure><p>这个通配符限制为所有Manager的超类型。</p><p><img src="1552639688776.png" alt=""></p><p>可以为方法提供参数，但不能使用返回值。</p><p>直观地讲，<strong>带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。</strong></p><h3 id="8-8-3-无限定通配符"><a href="#8-8-3-无限定通配符" class="headerlink" title="8.8.3 无限定通配符"></a>8.8.3 无限定通配符</h3><p>可以使用无限定的通配符，它与原始的Pair类型有很大不同。</p><p>Pair&lt;?&gt;有以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? getFirst()<span class="comment">//返回值只能赋给一个Object。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(?)</span><span class="comment">//该方法不能被调用（也不能用Object调用</span></span></span><br></pre></td></tr></table></figure><p><strong>注：可以调用setFirst(null)</strong></p><p>为什么要使用这样脆弱的类型呢？它对于许多简单的操作非常有用。例如下面这个方法将用来测试一个pair是否包含null引用，它不需要实际的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.getFirst == <span class="keyword">null</span> || p.getSecond == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-9-反射和泛型"><a href="#8-9-反射和泛型" class="headerlink" title="8.9 反射和泛型"></a>8.9 反射和泛型</h2><blockquote><p><a href="https://juejin.im/post/5abb78b56fb9a028e25d9c32" target="_blank" rel="noopener">https://juejin.im/post/5abb78b56fb9a028e25d9c32</a> 通俗易懂一些。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第8章-泛型程序设计&quot;&gt;&lt;a href=&quot;#第8章-泛型程序设计&quot; class=&quot;headerlink&quot; title=&quot;第8章 泛型程序设计&quot;&gt;&lt;/a&gt;第8章 泛型程序设计&lt;/h1&gt;&lt;p&gt;泛型对于集合类尤其有用，ArrayList就是一个无处不在的类。
    
    </summary>
    
      <category term="Java核心技术卷Ⅰ读书笔记" scheme="https://wcxdhr.github.io/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java读书笔记系列 第7章 异常、断言和日志</title>
    <link href="https://wcxdhr.github.io/2019/03/13/Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC7%E7%AB%A0-%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/"/>
    <id>https://wcxdhr.github.io/2019/03/13/Java读书笔记系列-第7章-异常、断言和日志/</id>
    <published>2019-03-13T12:44:25.000Z</published>
    <updated>2019-03-13T15:50:36.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第7章-异常、断言和日志"><a href="#第7章-异常、断言和日志" class="headerlink" title="第7章 异常、断言和日志"></a>第7章 异常、断言和日志</h1><h2 id="7-1-处理错误"><a href="#7-1-处理错误" class="headerlink" title="7.1 处理错误"></a>7.1 处理错误</h2><h3 id="7-1-1-异常分类"><a href="#7-1-1-异常分类" class="headerlink" title="7.1.1 异常分类"></a>7.1.1 异常分类</h3><p><img src="1552293327061.png" alt=""></p><ul><li>Error类：Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出。<a id="more"></a></li><li>Exception类：</li><li><ul><li>RuntimeException：由于程序错误导致的异常。有以下情况</li><li><ul><li>错误的类型转换。</li><li>数组访问越界。</li><li>访问null指针。</li></ul></li><li>IOException：程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。</li><li><ul><li>试图在文件尾部后面读取数据。</li><li>试图打开一个不存在的文件。</li><li>试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。</li></ul></li></ul></li></ul><p><strong>“如果出现RuntimeException异常，那一定就是你的问题”</strong>是一条相当有道理的规则。</p><p>Java语言规范将派生于Error类或RuntimeException类的所有异常称为<strong>非受查异常</strong>，所有其他的异常称为<strong>受查异常</strong>。编译器将核查是否为所有的受查异常提供了异常处理器。</p><h3 id="7-1-2-声明受查异常"><a href="#7-1-2-声明受查异常" class="headerlink" title="7.1.2 声明受查异常"></a>7.1.2 声明受查异常</h3><p>如果遇到了无法处理的情况，那么Java的方法可以抛出一个异常。一个方法不仅需要告诉编译器将要返回什么值，<strong>还要告诉编译器有可能发生什么错误</strong>。</p><p>方法应该在其首部声明所有可能抛出的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br></pre></td></tr></table></figure><p>在下面4种情况下应该抛出异常：</p><ul><li>调用一个抛出受查异常的方法，例如，FileInputStream构造器。</li><li>程序运行过程中发现错误，并且利用throw语句抛出一个受查异常。</li><li>程序出现错误，例如，a[-1]=0会抛出一个ArrayIndexOutBoundsException这样的非受查异常。</li><li>Java虚拟机和运行库出现的内部错误。</li></ul><h3 id="7-1-3-如何抛出异常"><a href="#7-1-3-如何抛出异常" class="headerlink" title="7.1.3 如何抛出异常"></a>7.1.3 如何抛出异常</h3><p>对于一个已经存在的类，将其抛出步骤如下：</p><ul><li>找到一个合适的异常类</li><li>创建这个类的一个对象</li><li>将对象抛出</li></ul><h2 id="7-2-捕获异常"><a href="#7-2-捕获异常" class="headerlink" title="7.2 捕获异常"></a>7.2 捕获异常</h2><h3 id="7-2-1-捕获异常"><a href="#7-2-1-捕获异常" class="headerlink" title="7.2.1 捕获异常"></a>7.2.1 捕获异常</h3><p>要想捕获异常，必须设置try/catch语句块，如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，那么：</p><ul><li>程序将跳过try语句块的其余代码。</li><li>程序将执行catch子句中的处理器代买。</li></ul><p>传递异常：在方法声明后throws IOException。</p><p><strong>应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递。</strong></p><h3 id="7-2-4-finally子句"><a href="#7-2-4-finally子句" class="headerlink" title="7.2.4 finally子句"></a>7.2.4 finally子句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(...);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure><p>以上代码，在3种情况下会执行finally子句：</p><ul><li><p>代码没有抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>-<span class="keyword">finally</span><span class="comment">//执行1-2-5-6</span></span><br></pre></td></tr></table></figure></li><li><p>抛出一个在catch子句中捕获的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>-<span class="keyword">catch</span>-<span class="keyword">finally</span><span class="comment">//执行1-3-4-5-6</span></span><br><span class="line"><span class="comment">//若catch子句抛出异常，异常会被抛回这个方法的调用者，执行1-3-5</span></span><br></pre></td></tr></table></figure></li><li><p>代码抛出一个异常但这个异常不是由catch子句捕获的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>-<span class="keyword">finally</span><span class="comment">//执行1-5</span></span><br></pre></td></tr></table></figure></li></ul><p>try语句可以只有finally子句，没有catch子句。</p><h3 id="7-2-5-带资源的try语句"><a href="#7-2-5-带资源的try语句" class="headerlink" title="7.2.5 带资源的try语句"></a>7.2.5 带资源的try语句</h3><p>带资源的try语句最简形式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Resource res = ...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try块退出时，会自动调用res.close()。</p><h2 id="7-3-使用异常机制的技巧"><a href="#7-3-使用异常机制的技巧" class="headerlink" title="7.3 使用异常机制的技巧"></a>7.3 使用异常机制的技巧</h2><ul><li><p>异常处理不能代替简单的测试</p><p>与执行简单的测试相比，捕获异常所花费的世间大大超过了前者，使用异常的基本规则是：只在异常情况下使用异常机制。</p></li><li><p>不要过分细化异常</p></li><li><p>利用异常层次结构</p><p>不要只抛出RuntimeException异常。应该寻找更加适当的子类或创建自己的异常类。</p><p>不要只捕获Thowable异常，否则会使代码更难读、更难维护。‘</p><p>考虑受查异常和非受查异常的区别。已检查异常本来就很庞大，不要为逻辑错误抛出这些异常。</p></li><li><p>不要压制异常</p><p>书上这里看不懂，不知道在讲什么。</p><p>网上查阅结果：</p><p>不要在catch子句中压制异常（例如在子句中return null），如果不知道如何处理异常，最好将异常重新抛出，由上层决定如何处理异常。</p></li><li><p>在检测错误时，“苛刻”要比放任更好</p></li><li><p>不要羞于传递异常</p></li></ul><p>注：最后两条归纳为<strong>早抛出，晚捕获“</strong></p><h2 id="7-4-使用断言"><a href="#7-4-使用断言" class="headerlink" title="7.4 使用断言"></a>7.4 使用断言</h2><p>在一个具有自我保护能力的程序中，断言很常用。</p><p>断言机制允许在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句会被自动移走。</p><p>Java语言引入了关键字assert。这个关键字有两种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> 条件;</span><br><span class="line"><span class="keyword">assert</span> 条件 : 表达式;</span><br></pre></td></tr></table></figure><p>如果结果为false，则抛出一个AssertionError异常。第二种形式中，表达式将被传入AssertionError的构造器，并转换成一个消息字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码断言x是一个非负数值</span></span><br><span class="line"><span class="keyword">assert</span> x =&gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">//或传给AssertionError</span></span><br><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : x;</span><br></pre></td></tr></table></figure><h3 id="7-4-2-启用和禁用断言"><a href="#7-4-2-启用和禁用断言" class="headerlink" title="7.4.2 启用和禁用断言"></a>7.4.2 启用和禁用断言</h3><p>在默认情况下，断言被禁用。可以在运行程序时用-enableassertions或-ea选项启用。</p><h3 id="7-4-3-使用断言完成参数检查"><a href="#7-4-3-使用断言完成参数检查" class="headerlink" title="7.4.3 使用断言完成参数检查"></a>7.4.3 使用断言完成参数检查</h3><p>在Java语言中，给出了3种处理系统错误的机制：</p><ul><li>抛出一个异常</li><li>日志</li><li>使用断言</li></ul><p>使用断言要注意以下几点：</p><ul><li>断言失败是致命的、不可恢复的错误。</li><li>断言检查只用于开发和测阶段。</li></ul><h2 id="7-5-记录日志"><a href="#7-5-记录日志" class="headerlink" title="7.5 记录日志"></a>7.5 记录日志</h2><p>记录日志API的优点：</p><ul><li>可以很容易地取消全部日志记录，或者仅仅取消某个级别的日志，而且打开和关闭这个操作也很容易。</li><li>可以很简单地禁止日志记录地输出，因此，将这些日志代码留在程序中开销很小。</li><li>日志记录可以被定向到不同的处理器，用于在控制台显示，用于存储在文件中等。</li><li>日志记录器和处理器都可以对日志进行过滤。过滤器可以根据过滤实现器制定的标准丢弃那些无用地记录项。</li><li>日志记录可以采用不同的方法格式化，例如，纯文本或XML。</li><li>应用程序可以使用多个日志记录器，它们使用类似包名地这种具有层次结构的名字。</li><li>在默认情况下，日志系统的配置由配置文件控制。如果需要的话，应用程序可以替换这个配置。</li></ul><h3 id="7-5-2-高级日志"><a href="#7-5-2-高级日志" class="headerlink" title="7.5.2 高级日志"></a>7.5.2 高级日志</h3><p>调用getLogger方法创建或获取记录器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger myLogger = Logger.getLogger(<span class="string">"com.mycompany.myapp"</span>);</span><br></pre></td></tr></table></figure><p>日志记录器有7个级别：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.setLevel(Level.FINE);<span class="comment">//FINE和更高级别的记录都可以记录下来。</span></span><br></pre></td></tr></table></figure><h3 id="7-5-8-日志记录说明"><a href="#7-5-8-日志记录说明" class="headerlink" title="7.5.8 日志记录说明"></a>7.5.8 日志记录说明</h3><p>以下是一些最常用的操作：</p><ul><li>为一个简单的应用程序，选择一个日志记录器，并把日志记录器命名为与主应用程序包一样的名字，这是一种好的编程习惯。</li><li>默认的日志配置将级别等于或高于INFO级别的所有消息记录到控制台。用户可以覆盖默认的配置文件。但改变需要做相当多的工作，因此，最好在应用程序中安装一个更加适宜的默认配置。</li><li>由于等于或高于INFO级别的消息都显示在控制台上，最好只将对程序用户有意义的消息设置为这几个级别，将程序员想要的日志记录设定为FINE是一个很好的选择。</li></ul><h2 id="7-6-调试技巧"><a href="#7-6-调试技巧" class="headerlink" title="7.6 调试技巧"></a>7.6 调试技巧</h2><ul><li><p>可以用下面的方法打印或记录任意变量的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"x="</span> + x);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">Logger.getGlobal().info(<span class="string">"x="</span> + x);</span><br></pre></td></tr></table></figure><p>若x是一个数值，则会被转换成等价的字符串。若x是一个对象，则Java会调用这个对象的toString方法。</p></li><li><p>一个有效技巧是在每一个类中放置一个单独的main方法，用以对每个类进行单元测试。</p></li><li><p>JUnit是一个非常常见的单元测试框架。</p></li><li><p>日志代理是一个子类的对象，它可以截获方法调用，并进行日志记录，然后调用超类中的方法。</p></li><li><p>利用Throwable类提供的printStackTrace方法，可以从任何一个异常对象中获得堆栈情况。</p></li><li><p>一般来说，堆栈轨迹显示在System.err上。也可以利用printStackTrace(PrintWriter s)方法将它发送到一个文件中。</p></li></ul><p>后续省略。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第7章-异常、断言和日志&quot;&gt;&lt;a href=&quot;#第7章-异常、断言和日志&quot; class=&quot;headerlink&quot; title=&quot;第7章 异常、断言和日志&quot;&gt;&lt;/a&gt;第7章 异常、断言和日志&lt;/h1&gt;&lt;h2 id=&quot;7-1-处理错误&quot;&gt;&lt;a href=&quot;#7-1-处理错误&quot; class=&quot;headerlink&quot; title=&quot;7.1 处理错误&quot;&gt;&lt;/a&gt;7.1 处理错误&lt;/h2&gt;&lt;h3 id=&quot;7-1-1-异常分类&quot;&gt;&lt;a href=&quot;#7-1-1-异常分类&quot; class=&quot;headerlink&quot; title=&quot;7.1.1 异常分类&quot;&gt;&lt;/a&gt;7.1.1 异常分类&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;1552293327061.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Error类：Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出。
    
    </summary>
    
      <category term="Java核心技术卷Ⅰ读书笔记" scheme="https://wcxdhr.github.io/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java读书笔记系列 第6章 接口、lambda表达式与内部类</title>
    <link href="https://wcxdhr.github.io/2019/03/13/Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC6%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://wcxdhr.github.io/2019/03/13/Java读书笔记系列-第6章-接口、lambda表达式与内部类/</id>
    <published>2019-03-13T12:44:02.000Z</published>
    <updated>2019-03-13T15:50:48.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第6章-接口、lambda表达式与内部类"><a href="#第6章-接口、lambda表达式与内部类" class="headerlink" title="第6章 接口、lambda表达式与内部类"></a>第6章 接口、lambda表达式与内部类</h1><h2 id="6-1-接口"><a href="#6-1-接口" class="headerlink" title="6.1 接口"></a>6.1 接口</h2><p>接口技术用来描述类具有什么功能，并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要的地方，随时使用实现了相应接口的的对象。<a id="more"></a></p><p>接口中的所有方法自动地属于public。因此，在接口中声明方法时，不必提供关键字public。<strong>在实现接口时，必须把方法声明为public</strong> </p><p>接口绝不能含有实例域——接口没有实例。但接口中可以包含常量（public static final constant)。接口可以被扩展。</p><p>提供实例域和方法实现的任务应该由实现接口的那个类来完成。可以将接口看成没有实例域的抽象类。</p><p>为了让类实现一个接口，通常需要下面两个步骤：</p><ul><li>将类声明为实现给定的接口</li><li>对接口中的所有方法进行定义</li></ul><h3 id="6-1-3-接口与抽象类"><a href="#6-1-3-接口与抽象类" class="headerlink" title="6.1.3 接口与抽象类"></a>6.1.3 接口与抽象类</h3><p>每个类只能继承一个类（C++的多重继承会让语言本身变得非常复杂），但每个类可以实现多个接口。</p><p>接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p><h3 id="6-1-6-默认方法冲突"><a href="#6-1-6-默认方法冲突" class="headerlink" title="6.1.6 默认方法冲突"></a>6.1.6 默认方法冲突</h3><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，规则如下：</p><ul><li>超类优先。如果超类提供了一个具体方法，同名而且有相同的参数类型的默认方法会被忽略。</li><li>接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否默认参数）相同的方法，必须覆盖这个方法来解决冲突。</li></ul><h2 id="6-3-lambda（λ）表达式"><a href="#6-3-lambda（λ）表达式" class="headerlink" title="6.3 lambda（λ）表达式"></a>6.3 lambda（λ）表达式</h2><h3 id="6-3-2-lambda表达式语法"><a href="#6-3-2-lambda表达式语法" class="headerlink" title="6.3.2 lambda表达式语法"></a>6.3.2 lambda表达式语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second)</span><br><span class="line">-&gt; first.lengthh() - second.length()</span><br></pre></td></tr></table></figure><p>以上是一种lambda表达式形式：参数，箭头（-&gt;)以及一个表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，可将表达式变为方法，放在一个代码块中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><p>没有参数时，仍然要提供空括号。</p><p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型；如果方法只有一个参数，而且这个参数类型可以推导得出，则还可以省略()。</p><p>无需指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出。</p><h3 id="6-3-3-函数式接口"><a href="#6-3-3-函数式接口" class="headerlink" title="6.3.3 函数式接口"></a>6.3.3 函数式接口</h3><p>对于只有一个抽象方法的接口，当需要这种接口的对象时，就可以提供lambda表达式。这种接口称为函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words,</span><br><span class="line">           (first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure><p>Arrays.sort的第二个参数需要一个Comparator实例，在这里提供一个lambda表达式。</p><p>在底层，Arrays.sort方法会接收实现了Comparator<string>的某个类的对象。在这个对象上调用compare方法会执行这个lambda表达式的体。</string></p><p>在Java中，lambda表达式只能转换为函数式接口。</p><h3 id="6-3-4-方法引用"><a href="#6-3-4-方法引用" class="headerlink" title="6.3.4 方法引用"></a>6.3.4 方法引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, event -&gt; System.out.println(event));</span><br><span class="line"><span class="comment">//出现一个定时器事件就打印这个事件对象</span></span><br><span class="line">Timer t = newTimer(<span class="number">1000</span>, System.out::println);</span><br><span class="line"><span class="comment">//System.out::println为一个方法引用，等价于x -&gt; System.out.println(x)</span></span><br></pre></td></tr></table></figure><p><em>注：第四节内部类后未看</em> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第6章-接口、lambda表达式与内部类&quot;&gt;&lt;a href=&quot;#第6章-接口、lambda表达式与内部类&quot; class=&quot;headerlink&quot; title=&quot;第6章 接口、lambda表达式与内部类&quot;&gt;&lt;/a&gt;第6章 接口、lambda表达式与内部类&lt;/h1&gt;&lt;h2 id=&quot;6-1-接口&quot;&gt;&lt;a href=&quot;#6-1-接口&quot; class=&quot;headerlink&quot; title=&quot;6.1 接口&quot;&gt;&lt;/a&gt;6.1 接口&lt;/h2&gt;&lt;p&gt;接口技术用来描述类具有什么功能，并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要的地方，随时使用实现了相应接口的的对象。
    
    </summary>
    
      <category term="Java核心技术卷Ⅰ读书笔记" scheme="https://wcxdhr.github.io/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java读书笔记系列 第5章 继承</title>
    <link href="https://wcxdhr.github.io/2019/03/13/Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF/"/>
    <id>https://wcxdhr.github.io/2019/03/13/Java读书笔记系列-第5章-继承/</id>
    <published>2019-03-13T12:43:34.000Z</published>
    <updated>2019-03-13T15:50:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第5章-继承"><a href="#第5章-继承" class="headerlink" title="第5章 继承"></a>第5章 继承</h1><h2 id="5-1-类、超类和子类"><a href="#5-1-类、超类和子类" class="headerlink" title="5.1 类、超类和子类"></a>5.1 类、超类和子类</h2><p>通过扩展超类定义子类时，只需指出子类与超类的不同之处。</p><p>使用关键字super调用超类。<a id="more"></a></p><p>一个对象变量可以指示多种实际类型的现象被称为<strong>多态</strong>。</p><p>在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定</strong>。</p><p><strong>动态绑定的重要特性</strong>：无需对现存的代码进行修改，就可以对程序进行扩展。不需要重新编译。</p><h3 id="5-1-7-阻止继承：final类和方法"><a href="#5-1-7-阻止继承：final类和方法" class="headerlink" title="5.1.7 阻止继承：final类和方法"></a>5.1.7 阻止继承：final类和方法</h3><p>final类不允许被扩展，final方法不能被覆盖。</p><h3 id="5-1-8-强制类型转换"><a href="#5-1-8-强制类型转换" class="headerlink" title="5.1.8 强制类型转换"></a>5.1.8 强制类型转换</h3><p>将超类的引用赋给一个子类变量，必须进行类型转换。</p><ul><li>只能在继承层次内进行类型转换。</li><li>在将超类转换为子类之前，应该使用instanceof进行检查。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (staff[<span class="number">1</span>] <span class="keyword">instanceof</span> Manager) &#123;</span><br><span class="line">    boss = (Manager) staff[<span class="number">1</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//instanceof:通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例</span></span><br></pre></td></tr></table></figure><p>在一般情况下，应该减少使用类型转换和instanceof运算符。</p><h3 id="5-1-9-抽象类"><a href="#5-1-9-抽象类" class="headerlink" title="5.1.9 抽象类"></a>5.1.9 抽象类</h3><p>包含一个或多个抽象方法的类必须被声明为抽象的。</p><p>抽象类可以不含有抽象方法。</p><h3 id="5-1-10-受保护访问"><a href="#5-1-10-受保护访问" class="headerlink" title="5.1.10 受保护访问"></a>5.1.10 受保护访问</h3><p>Java用于控制可见性的4个访问修饰符：</p><ul><li>仅对本类可见-private</li><li>对所有类可见-public</li><li>对本包和所有子类可见-protected</li><li>对本包可见-默认，不需要修饰符</li></ul><h2 id="5-2-Object：所有类的超类"><a href="#5-2-Object：所有类的超类" class="headerlink" title="5.2 Object：所有类的超类"></a>5.2 Object：所有类的超类</h2><h3 id="5-2-4-toString方法"><a href="#5-2-4-toString方法" class="headerlink" title="5.2.4 toString方法"></a>5.2.4 toString方法</h3><p>toString方法用于返回表示对象值的字符串。</p><p>只要对象与一个字符串通过操作符“+”连接起来，Java编译会自动调用toString方法，以获得该对象的字符串描述。</p><p>toString方法是一种非常有用的调试工具。</p><h2 id="5-3-泛型数组列表"><a href="#5-3-泛型数组列表" class="headerlink" title="5.3 泛型数组列表"></a>5.3 泛型数组列表</h2><p>ArrayList是一个采用类型参数的泛型类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//声明和构造一个保存Employee对象的数组列表</span></span><br></pre></td></tr></table></figure><h2 id="5-6-枚举类"><a href="#5-6-枚举类" class="headerlink" title="5.6 枚举类"></a>5.6 枚举类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size &#123; SMALL, MEDIUM, LARGE, EXTRA_LARGE &#125;;</span><br></pre></td></tr></table></figure><p>这个声明定义的类型是一个类，它有四个实例。</p><h2 id="5-7-反射"><a href="#5-7-反射" class="headerlink" title="5.7 反射"></a>5.7 反射</h2><p>能够分析类能力的程序称为<strong>反射</strong>。</p><p>反射机制用来：</p><ul><li>在运行时分析类的能力</li><li>在运行时查看对象，例如，编写一个toString方法供所有类使用。</li><li>实现通用的数组操作代码</li><li>利用Method对象，这个对象很像C++中的函数指针</li></ul><h3 id="5-7-1-Class类"><a href="#5-7-1-Class类" class="headerlink" title="5.7.1 Class类"></a>5.7.1 Class类</h3><p>程序运行时，Java运行时系统为所有对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。</p><p>保存这些信息的类为Class， Object类中的getClass()将返回一个Class类型的实例。</p><p>获得Class类对象的三种方法：</p><ul><li><p>Object类的getClass()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">Class cl = e.getClass();</span><br></pre></td></tr></table></figure></li><li><p>静态方法forName获得类名对应的Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">"java.util.Random"</span>;</span><br><span class="line">Class cl = Class.forName(className);<span class="comment">//要求className是类名或接口名</span></span><br></pre></td></tr></table></figure></li><li><p>T.class(T为任意的Java类型)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cl1 = <span class="keyword">int</span>.class;</span><br><span class="line">Class cl2 = Double[].class;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-7-2-捕获异常"><a href="#5-7-2-捕获异常" class="headerlink" title="5.7.2 捕获异常"></a>5.7.2 捕获异常</h3><p>异常有两种类型：未检查异常和已检查异常。</p><p>未检查异常尽量避免。</p><p>对于已检查异常，编译器会检查是否提供了处理器。将可能抛出已检查异常的方法调用代码放在try块中，然后在catch子句中提供处理器代码。</p><h3 id="5-7-3-利用反射分析类的能力"><a href="#5-7-3-利用反射分析类的能力" class="headerlink" title="5.7.3 利用反射分析类的能力"></a>5.7.3 利用反射分析类的能力</h3><p>java.lang.reflection中有这三个类：</p><ul><li>Field 描述类的域</li><li>Method 描述类的方法</li><li>Constructor 描述类的构造器</li></ul><p>这三个类通用：</p><ul><li>getName方法，返回项目名称</li><li>getModifiers方法，返回整数值，用不同的位开关描述public和static这样的修饰符使用情况。</li></ul><h3 id="5-7-6-调用任意方法"><a href="#5-7-6-调用任意方法" class="headerlink" title="5.7.6 调用任意方法"></a>5.7.6 调用任意方法</h3><p>Method类的invoke方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br></pre></td></tr></table></figure><p>第一个参数是隐式参数，其余对象提供显式参数，对于静态方法，第一个参数可以被忽略，设置为null。</p><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String n = (String) m1.invoke(harry);</span><br><span class="line"><span class="comment">//m1表示Employee类的getName方法，这条语句调用该方法</span></span><br></pre></td></tr></table></figure><p>使用反射获得方法指针比仅仅直接调用方法更慢。</p><h2 id="5-8-继承设计技巧"><a href="#5-8-继承设计技巧" class="headerlink" title="5.8 继承设计技巧"></a>5.8 继承设计技巧</h2><ul><li><p>将公共操作和域放在超类</p></li><li><p>不要使用受保护的域</p><p>一般不要使用，除protected方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用。</p></li><li><p>在覆盖方法时，不要改变预期的行为</p></li><li><p>使用多态，而非类型信息（方法参数类型不同）</p></li><li><p>不要过多地使用反射</p><p>反射机制对于编写系统程序的人来说极其实用，但通常不适于编写应用程序。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第5章-继承&quot;&gt;&lt;a href=&quot;#第5章-继承&quot; class=&quot;headerlink&quot; title=&quot;第5章 继承&quot;&gt;&lt;/a&gt;第5章 继承&lt;/h1&gt;&lt;h2 id=&quot;5-1-类、超类和子类&quot;&gt;&lt;a href=&quot;#5-1-类、超类和子类&quot; class=&quot;headerlink&quot; title=&quot;5.1 类、超类和子类&quot;&gt;&lt;/a&gt;5.1 类、超类和子类&lt;/h2&gt;&lt;p&gt;通过扩展超类定义子类时，只需指出子类与超类的不同之处。&lt;/p&gt;
&lt;p&gt;使用关键字super调用超类。
    
    </summary>
    
      <category term="Java核心技术卷Ⅰ读书笔记" scheme="https://wcxdhr.github.io/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java读书笔记系列 第4章 对象与类</title>
    <link href="https://wcxdhr.github.io/2019/03/13/Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"/>
    <id>https://wcxdhr.github.io/2019/03/13/Java读书笔记系列-第4章-对象与类/</id>
    <published>2019-03-13T12:40:18.000Z</published>
    <updated>2019-03-13T15:51:12.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第4章-对象与类"><a href="#第4章-对象与类" class="headerlink" title="第4章 对象与类"></a>第4章 对象与类</h1><h3 id="4-1-4-类之间的关系"><a href="#4-1-4-类之间的关系" class="headerlink" title="4.1.4 类之间的关系"></a>4.1.4 类之间的关系</h3><ul><li><p>依赖（uses-a）</p><p>一个类的方法操纵另一个类的对象，应尽可能减少依赖，<em>让类之间的耦合度最小</em>（Order对象使用Account对象查看信用状态）<a id="more"></a></p></li><li><p>聚合（has-a）</p><p>类A的对象包含类B的对象（Order对象包含一些Item对象）</p></li><li><p>继承（is-a）</p><p>类A扩展类B，继承类B（RushOrder类继承Order类）</p></li></ul><p><img src="1551258991671.png" alt=""></p><h3 id="4-2-1-对象与对象变量"><a href="#4-2-1-对象与对象变量" class="headerlink" title="4.2.1 对象与对象变量"></a>4.2.1 对象与对象变量</h3><p><strong>对象与对象变量的区别</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date deadline;<span class="comment">//deadline是对象变量，未指向任何对象</span></span><br></pre></td></tr></table></figure><p>变量deadline不是一个对象，也没有引用对象，必须首先<strong>初始化变量</strong>。 可以使用新构造的对象初始化变量，也可以让变量引用一个已存在的对象（这样两个变量引用同一个对象）</p><p><strong>注：</strong>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。</p><p>在Java中，任何对象变量的值都是对存储在另一个地方的一个对象的引用。new操作符的返回值也是一个引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date deadline = <span class="keyword">new</span> Date();<span class="comment">//表达式new Date()构造了一个Date类型的对象，并且它的值是对新创建对象的引用。这个引用存储在变量deadline中。</span></span><br></pre></td></tr></table></figure><p><strong>所有的Java对象都是在堆中构造的</strong></p><h3 id="4-3-5-隐式参数与显式参数"><a href="#4-3-5-隐式参数与显式参数" class="headerlink" title="4.3.5 隐式参数与显式参数"></a>4.3.5 隐式参数与显式参数</h3><p>在每一个方法中，关键字this表示隐式参数。</p><h3 id="4-3-6-封装的优点"><a href="#4-3-6-封装的优点" class="headerlink" title="4.3.6 封装的优点"></a>4.3.6 封装的优点</h3><p><strong>不要返回引用可变对象的访问器方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;<span class="comment">//Bad 因为Date有一个更改器方法setTime，可以更改对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee harry = ...;</span><br><span class="line">Date d = harry.getHireDay();</span><br><span class="line"><span class="keyword">double</span> tempTime = <span class="number">10</span> * <span class="number">12345</span>;</span><br><span class="line">d.setTime(d.getTime() - (<span class="keyword">long</span>) tempTime);<span class="comment">//这里d和harry.hireDay引用同一个对象，对象已改变。</span></span><br></pre></td></tr></table></figure><p><img src="1551336870827.png" alt=""></p><p>如果需要返回一个可变数据域的拷贝，应该使用clone。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Date) hireDay.clone();<span class="comment">//Ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-7-基于类的访问权限"><a href="#4-3-7-基于类的访问权限" class="headerlink" title="4.3.7 基于类的访问权限"></a>4.3.7 基于类的访问权限</h3><p>一个方法可以访问<strong>所属类的所有对象的私有数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Employee other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.equals(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(harry.equals(boss)) ...</span><br></pre></td></tr></table></figure><h3 id="4-3-9-final实例域"><a href="#4-3-9-final实例域" class="headerlink" title="4.3.9 final实例域"></a>4.3.9 final实例域</h3><p>final实例域必须在构建对象时初始化，且之后不会再被修改。</p><h2 id="4-4-静态域"><a href="#4-4-静态域" class="headerlink" title="4.4 静态域"></a>4.4 静态域</h2><p>静态域属于类，不属于任何一个独立的对象。</p><p>静态方法使用情况：</p><ul><li>一个方法不需要要访问对象状态，所需参数都是通过显式提供。</li><li>一个方法只需要访问类的静态域。</li></ul><h2 id="4-5-方法参数"><a href="#4-5-方法参数" class="headerlink" title="4.5 方法参数"></a>4.5 方法参数</h2><p>Java总是按值调用，方法得到的是所有参数值的一个拷贝，不能修改传递给它的任何参数变量的内容。</p><p>方法参数有两种类型：</p><ul><li>基本数据类型（数字、布尔型）</li><li>对象引用</li></ul><p>一个方法不能修改一个基本数据类型的参数，但可以改变对象引用的值。（方法得到的是对象引用的拷贝，对象引用及其拷贝引用同一个对象，可以由此修改所引用的对象状态）</p><p><img src="1551339471365.png" alt=""></p><p>总结Java中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数</li><li>一个方法可以改变一个对象参数的状态</li><li>一个方法不能让对象参数引用一个新的对象</li></ul><h2 id="4-7-包"><a href="#4-7-包" class="headerlink" title="4.7 包"></a>4.7 包</h2><p>只能使用*导入一个包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*<span class="comment">//Ok</span></span><br><span class="line"><span class="keyword">import</span> java.*<span class="comment">//No</span></span><br><span class="line"><span class="keyword">import</span> java.*.*<span class="comment">//No</span></span><br></pre></td></tr></table></figure><p>当要使用两个包内同名的类时，将这个具体的类导入。</p><h2 id="4-9-文档注释"><a href="#4-9-文档注释" class="headerlink" title="4.9 文档注释"></a>4.9 文档注释</h2><h3 id="4-9-2-类注释"><a href="#4-9-2-类注释" class="headerlink" title="4.9.2 类注释"></a>4.9.2 类注释</h3><p>类注释必须放在import语句之后，类定义之前。</p><h3 id="4-9-3-方法注释"><a href="#4-9-3-方法注释" class="headerlink" title="4.9.3 方法注释"></a>4.9.3 方法注释</h3><p>方法注释放在所描述的方法之前。</p><h2 id="4-10-类设计技巧"><a href="#4-10-类设计技巧" class="headerlink" title="4.10 类设计技巧"></a>4.10 类设计技巧</h2><ul><li>一定要保证数据私有（不破坏封装性）</li><li>一定要对数据初始化</li><li>不要在类中使用过多的基本类型（用其他的类代替多个相关的基本类型的使用）</li><li>不是所有的域都需要独立的域访问器和域更改器</li><li>将职责过多的类进行分解</li><li>类名和方法名要能够体现它们的职责</li><li>优先使用不可变的类</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第4章-对象与类&quot;&gt;&lt;a href=&quot;#第4章-对象与类&quot; class=&quot;headerlink&quot; title=&quot;第4章 对象与类&quot;&gt;&lt;/a&gt;第4章 对象与类&lt;/h1&gt;&lt;h3 id=&quot;4-1-4-类之间的关系&quot;&gt;&lt;a href=&quot;#4-1-4-类之间的关系&quot; class=&quot;headerlink&quot; title=&quot;4.1.4 类之间的关系&quot;&gt;&lt;/a&gt;4.1.4 类之间的关系&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;依赖（uses-a）&lt;/p&gt;
&lt;p&gt;一个类的方法操纵另一个类的对象，应尽可能减少依赖，&lt;em&gt;让类之间的耦合度最小&lt;/em&gt;（Order对象使用Account对象查看信用状态）
    
    </summary>
    
      <category term="Java核心技术卷Ⅰ读书笔记" scheme="https://wcxdhr.github.io/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java读书笔记系列 第3章 Java基本程序设计结构</title>
    <link href="https://wcxdhr.github.io/2019/03/13/Java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"/>
    <id>https://wcxdhr.github.io/2019/03/13/Java读书笔记系列-第3章-Java基本程序设计结构/</id>
    <published>2019-03-13T12:31:18.000Z</published>
    <updated>2019-03-13T15:51:22.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章-Java基本程序设计结构"><a href="#第3章-Java基本程序设计结构" class="headerlink" title="第3章 Java基本程序设计结构"></a>第3章 Java基本程序设计结构</h1><h3 id="3-5-2"><a href="#3-5-2" class="headerlink" title="3.5.2"></a>3.5.2</h3><p>Math.round：四舍五入（返回long类型）<a id="more"></a></p><h2 id="3-6-字符串"><a href="#3-6-字符串" class="headerlink" title="3.6  字符串"></a>3.6  字符串</h2><p>substring方法：提取子串</p><p>+：连接</p><p>String类对象：不可变字符串（修改字符串变量以引用另一个字符串），优点：编译器让字符串共享</p><p>equals方法：判断字符串是否相等（equalsIgnoreCase:不区分大小写）</p><p><strong>注</strong> ：==只能确定字符串是否放在同一个位置上（必然相等）</p><h3 id="3-6-5-空串与Null串"><a href="#3-6-5-空串与Null串" class="headerlink" title="3.6.5 空串与Null串"></a>3.6.5 空串与Null串</h3><p>空串长度为0，Null串str==null</p><h3 id="3-6-9-构建字符串"><a href="#3-6-9-构建字符串" class="headerlink" title="3.6.9 构建字符串"></a>3.6.9 构建字符串</h3><p>StringBuilder类：字符串构建器，适用于由较短的字符串构建字符串。</p><h2 id="3-8"><a href="#3-8" class="headerlink" title="3.8"></a>3.8</h2><h3 id="3-8-6"><a href="#3-8-6" class="headerlink" title="3.8.6"></a>3.8.6</h3><p>带标签的break语句：跳出多重循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">read_data:</span><br><span class="line"><span class="keyword">while</span>()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">break</span> read_data;</span><br><span class="line"><span class="comment">//跳出read_data所标记的循环  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-大数值"><a href="#3-9-大数值" class="headerlink" title="3.9 大数值"></a>3.9 大数值</h2><p>BigInteger </p><p>BigDecimal</p><h2 id="3-10-数组"><a href="#3-10-数组" class="headerlink" title="3.10 数组"></a>3.10 数组</h2><p><strong>初始值</strong></p><p>数字数组：0</p><p>布尔型数组：false</p><p>对象数组：null</p><p><strong>for each 循环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable : collection) statement</span><br><span class="line"><span class="comment">//example a:数组或实现了Iterable接口的类对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> element : a)</span><br><span class="line">    System.out.println(element);</span><br></pre></td></tr></table></figure><h3 id="3-10-3-数组拷贝"><a href="#3-10-3-数组拷贝" class="headerlink" title="3.10.3 数组拷贝"></a>3.10.3 数组拷贝</h3><p>一个数组变量拷贝给另一个数组变量：两个变量引用同一个数组</p><p><img src="1551256677685.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第3章-Java基本程序设计结构&quot;&gt;&lt;a href=&quot;#第3章-Java基本程序设计结构&quot; class=&quot;headerlink&quot; title=&quot;第3章 Java基本程序设计结构&quot;&gt;&lt;/a&gt;第3章 Java基本程序设计结构&lt;/h1&gt;&lt;h3 id=&quot;3-5-2&quot;&gt;&lt;a href=&quot;#3-5-2&quot; class=&quot;headerlink&quot; title=&quot;3.5.2&quot;&gt;&lt;/a&gt;3.5.2&lt;/h3&gt;&lt;p&gt;Math.round：四舍五入（返回long类型）
    
    </summary>
    
      <category term="Java核心技术卷Ⅰ读书笔记" scheme="https://wcxdhr.github.io/categories/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://wcxdhr.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Bupt OJ-302. 网络传输-网研14</title>
    <link href="https://wcxdhr.github.io/2018/03/20/Bupt-OJ-302-%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93-%E7%BD%91%E7%A0%9414/"/>
    <id>https://wcxdhr.github.io/2018/03/20/Bupt-OJ-302-网络传输-网研14/</id>
    <published>2018-03-20T05:32:28.000Z</published>
    <updated>2019-03-13T15:24:34.500Z</updated>
    
    <content type="html"><![CDATA[<p><img src="269.png" alt=""></p><p>刚开始拿Floyd做，直接内存和时间都超过，而且是错的，后来改成Dijkstra加全排列即通过。<a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000001</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>][<span class="number">1001</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    d[i][j]=j==i?<span class="number">0</span>:INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,m=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)<span class="keyword">if</span>(!a[k]&amp;&amp;d[i][k]&lt;=m)m=d[i][x=k];</span><br><span class="line">a[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)d[i][k]=min(d[i][k],d[i][x]+v[x][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> m,aim[<span class="number">11</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">   v[i][j]=INF;</span><br><span class="line">v[i][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v1,v2,e;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;v1,&amp;v2,&amp;e);</span><br><span class="line">v[v1][v2]=v[v2][v1]=e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;aim[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> sum=INF;</span><br><span class="line">aim[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">    dijkstra(aim[i]);</span><br><span class="line">sort(aim+<span class="number">1</span>,aim+k+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)tmp+=d[aim[i<span class="number">-1</span>]][aim[i]];</span><br><span class="line"><span class="keyword">if</span>(tmp&lt;sum)sum=tmp;</span><br><span class="line">&#125;<span class="keyword">while</span>(next_permutation(aim+<span class="number">1</span>,aim+k+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;269.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;刚开始拿Floyd做，直接内存和时间都超过，而且是错的，后来改成Dijkstra加全排列即通过。
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Bupt OJ" scheme="https://wcxdhr.github.io/tags/Bupt-OJ/"/>
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Bupt OJ-306. Python List-计算机一2014</title>
    <link href="https://wcxdhr.github.io/2018/03/18/Bupt-OJ-306-Python-List-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%802014/"/>
    <id>https://wcxdhr.github.io/2018/03/18/Bupt-OJ-306-Python-List-计算机一2014/</id>
    <published>2018-03-18T11:11:37.000Z</published>
    <updated>2019-03-13T15:28:06.270Z</updated>
    
    <content type="html"><![CDATA[<p><img src="273.png" alt=""></p><p>思路：利用vector和map配合进行模拟即可。<a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> n,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    a[i].clear();</span><br><span class="line">b.clear();</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">string</span> line,snum,opp;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c)&amp;&amp;c!=<span class="string">'='</span>&amp;&amp;c!=<span class="string">'.'</span>&amp;&amp;c!=<span class="string">'['</span>)<span class="comment">//得到List名 </span></span><br><span class="line">   snum.insert(snum.end(),<span class="number">1</span>,c);</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'='</span>)&#123;<span class="comment">//清空 </span></span><br><span class="line"><span class="keyword">if</span>(!b.count(snum))b[snum]=cnt++;</span><br><span class="line"><span class="keyword">else</span> a[b[snum]].clear();</span><br><span class="line">getline(<span class="built_in">cin</span>,line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'.'</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c)&amp;&amp;c!=<span class="string">'('</span>)</span><br><span class="line">opp.insert(opp.end(),<span class="number">1</span>,c);</span><br><span class="line"><span class="keyword">if</span>(opp[<span class="number">0</span>]==<span class="string">'a'</span>)&#123;<span class="comment">//插入 </span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">a[b[snum]].push_back(x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//排序 </span></span><br><span class="line">sort(a[b[snum]].begin(),a[b[snum]].end());</span><br><span class="line">&#125;</span><br><span class="line">getline(<span class="built_in">cin</span>,line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//查找 </span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(x&lt;a[b[snum]].size())<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[b[snum]][x]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"ERROR\n"</span>);</span><br><span class="line">getline(<span class="built_in">cin</span>,line);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;273.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;思路：利用vector和map配合进行模拟即可。
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Bupt OJ" scheme="https://wcxdhr.github.io/tags/Bupt-OJ/"/>
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Bupt OJ-305. 网络的核-计算机一2014</title>
    <link href="https://wcxdhr.github.io/2018/03/17/Bupt-OJ-305-%E7%BD%91%E7%BB%9C%E7%9A%84%E6%A0%B8-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%802014/"/>
    <id>https://wcxdhr.github.io/2018/03/17/Bupt-OJ-305-网络的核-计算机一2014/</id>
    <published>2018-03-17T14:54:43.000Z</published>
    <updated>2019-03-13T15:28:36.879Z</updated>
    
    <content type="html"><![CDATA[<p><img src="272.png" alt=""></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">55</span>];</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">55</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    d[j]=j==i?<span class="number">0</span>:n*n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,m=n*n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)<span class="keyword">if</span>(!v[k]&amp;&amp;d[k]&lt;=m)m=d[x=k];</span><br><span class="line">v[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)d[k]=min(d[k],d[x]+a[x][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    ans+=d[j];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">55</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    a[i][j]=n;</span><br><span class="line">a[i][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">a[v][u]=a[u][v]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">ans[i]=dijkstra(i,n);</span><br><span class="line"><span class="keyword">int</span> best=<span class="number">1</span>,mini=n*n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ans[i]&lt;mini)&#123;</span><br><span class="line">mini=ans[i];</span><br><span class="line">best=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,best);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;272.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Bupt OJ" scheme="https://wcxdhr.github.io/tags/Bupt-OJ/"/>
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Bupt OJ-304. 旋转图像-计算机一2014</title>
    <link href="https://wcxdhr.github.io/2018/03/17/Bupt-OJ-304-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%802014/"/>
    <id>https://wcxdhr.github.io/2018/03/17/Bupt-OJ-304-旋转图像-计算机一2014/</id>
    <published>2018-03-17T14:51:54.000Z</published>
    <updated>2019-03-13T15:28:46.114Z</updated>
    
    <content type="html"><![CDATA[<p><img src="271.png" alt=""></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"data.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,al;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;al);</span><br><span class="line"><span class="keyword">if</span>(!al)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(al==<span class="number">90</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(al==<span class="number">180</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;271.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Bupt OJ" scheme="https://wcxdhr.github.io/tags/Bupt-OJ/"/>
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Bupt OJ-303. 众数-计算机一2014</title>
    <link href="https://wcxdhr.github.io/2018/03/17/Bupt-OJ-303-%E4%BC%97%E6%95%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%802014/"/>
    <id>https://wcxdhr.github.io/2018/03/17/Bupt-OJ-303-众数-计算机一2014/</id>
    <published>2018-03-17T14:35:37.000Z</published>
    <updated>2019-03-13T15:28:54.604Z</updated>
    
    <content type="html"><![CDATA[<p><img src="270.png" alt=""></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;M;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">M.clear();</span><br><span class="line"><span class="keyword">int</span> n,mini;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">if</span>(!M.count(a[i]))M[a[i]]=<span class="number">0</span>;</span><br><span class="line">M[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">mini=a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(M[a[i]]&gt;M[mini])</span><br><span class="line">mini=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,mini);</span><br><span class="line"><span class="keyword">if</span>(T)<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;270.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Bupt OJ" scheme="https://wcxdhr.github.io/tags/Bupt-OJ/"/>
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>UVa 101 - The Blocks Problem</title>
    <link href="https://wcxdhr.github.io/2018/03/12/UVa-101-The-Blocks-Problem/"/>
    <id>https://wcxdhr.github.io/2018/03/12/UVa-101-The-Blocks-Problem/</id>
    <published>2018-03-12T10:37:21.000Z</published>
    <updated>2019-03-13T09:34:48.012Z</updated>
    
    <content type="html"><![CDATA[<p>木块问题，用vector保存木块堆，与书上代码差不多。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">25</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;wood[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> &amp;h,<span class="keyword">int</span> &amp;w)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;n;w++)</span><br><span class="line">   <span class="keyword">for</span>(h=<span class="number">0</span>;h&lt;wood[w].size();h++)</span><br><span class="line">      <span class="keyword">if</span>(wood[w][h]==a)<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h+<span class="number">1</span>;i&lt;wood[w].size();i++)</span><br><span class="line">wood[wood[w][i]].push_back(wood[w][i]);</span><br><span class="line">wood[w].resize(h+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a_moveto_b</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> ha,<span class="keyword">int</span> wa,<span class="keyword">int</span> wb)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=ha;i&lt;wood[wa].size();i++)</span><br><span class="line">wood[wb].push_back(wood[wa][i]);</span><br><span class="line">wood[wa].resize(ha);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("dataout.txt","w",stdout);</span></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">string</span> str1,str2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)wood[i].push_back(i);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str1&gt;&gt;a&gt;&gt;str2&gt;&gt;b&amp;&amp;str1[<span class="number">0</span>]!=<span class="string">'q'</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> wa,wb,ha,hb;</span><br><span class="line">find(a,ha,wa);</span><br><span class="line">find(b,hb,wb);</span><br><span class="line"><span class="keyword">if</span>(wa==wb)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(str1[<span class="number">0</span>]==<span class="string">'m'</span>)&#123;</span><br><span class="line">reset(a,wa,ha);</span><br><span class="line"><span class="keyword">if</span>(str2[<span class="number">1</span>]==<span class="string">'n'</span>)reset(b,wb,hb);</span><br><span class="line">a_moveto_b(a,b,ha,wa,wb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str2[<span class="number">1</span>]==<span class="string">'n'</span>)reset(b,wb,hb);</span><br><span class="line">a_moveto_b(a,b,ha,wa,wb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d:"</span>,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;wood[i].size();j++)<span class="built_in">printf</span>(<span class="string">" %d"</span>,wood[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;木块问题，用vector保存木块堆，与书上代码差不多。&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Uva 1590</title>
    <link href="https://wcxdhr.github.io/2018/03/10/uva-1590/"/>
    <id>https://wcxdhr.github.io/2018/03/10/uva-1590/</id>
    <published>2018-03-10T14:02:12.000Z</published>
    <updated>2019-03-13T09:34:57.229Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> ip[<span class="number">1005</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">4</span>][<span class="number">9</span>],str2[<span class="number">4</span>][<span class="number">9</span>],mask[<span class="number">4</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minAdr</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">8</span>,temp=ip[i][j];</span><br><span class="line"><span class="keyword">while</span>(k--)&#123;</span><br><span class="line">str2[j][k]=temp%<span class="number">2</span>;</span><br><span class="line">temp=temp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">8</span>;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag)</span><br><span class="line"><span class="keyword">if</span>(str2[j][k]!=str1[j][k])&#123;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="keyword">if</span>(i)str1[j][k]=mask[j][k]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> str1[j][k]=str2[j][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("dataout.txt","w",stdout);</span></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m)!=EOF)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;ip[i][j]);</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">str1[i][j]=mask[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">minAdr(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">ip[<span class="number">0</span>][j]=ip[<span class="number">1</span>][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">8</span>;k++)&#123;</span><br><span class="line">ip[<span class="number">0</span>][j]+=(str1[j][k]&lt;&lt;(<span class="number">7</span>-k));</span><br><span class="line">ip[<span class="number">1</span>][j]+=(mask[j][k]&lt;&lt;(<span class="number">7</span>-k));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)<span class="built_in">printf</span>(<span class="string">"%d.%d.%d.%d\n"</span>,ip[i][<span class="number">0</span>],ip[i][<span class="number">1</span>],ip[i][<span class="number">2</span>],ip[i][<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="OJ练习" scheme="https://wcxdhr.github.io/categories/OJ%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Code" scheme="https://wcxdhr.github.io/tags/Code/"/>
    
      <category term="练习" scheme="https://wcxdhr.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
</feed>
